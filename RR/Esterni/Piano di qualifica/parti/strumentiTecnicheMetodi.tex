
\subsection{Strumenti,tecniche e metodi}

\subsubsection{Strumenti}
\label{sec:strumenti}
Di seguito verranno elencati gli strumenti software che sono o saranno utilizzati dal gruppo per effettuare le operazioni di verifica e validazione:
\begin{itemize}

\item \textbf{Aspell}: correttore ortografico per documenti redatti in \LaTeX;

\item \textbf{Aptana}: scelto dal gruppo per la stesura del codice ha integrato al suo interno varie funzioni di debugging ed esecuzione del codice;

\item \textbf{W3C validator}: sito che controlla la validità dei markup nei documenti scritti in HTML;

\item \textbf{Jenkins}: sistema di per l'integrazione continua del codice e dei file latex;

\item \textbf{jSHint}: tool di supporto per la ricerca di eventuali errori nel codice javascript;

\item \textbf{Selenium IDE}: esentione di Firefox che permette di registrare test tramite browser;

\item \textbf{ApacheBrench}: strumento a linea di comando utilizzato per misurare l’efficienza di un server web ed in grado di simulare situazioni di sovraccarico della rete;

\item \textbf{SpeedTracer}: plugin per Google Chrome che permette di verificare l’efficienza di un’applicazione web durante la sua esecuzione.

Verranno utilizzati anche tutti gli strumenti già integrati all'interno del browser per lo sviluppo delle pagine web.

\end{itemize}
\subsubsection {Tecniche}
\begin{itemize}
\item \textbf{Analisi statica}: consiste nell’analizzare il codice tramite tools e letture senza tuttavia eseguirlo. Data la natura di questo tipo di analisi, è possibile applicarla anche per il controllo di tutti i documenti testuali prodotti.
Si esegue applicando i due seguenti metodi:
\begin{itemize}
\item \textbf{Inspection}: l’obiettivo di questa tecnica di analisi è l’individuazione di difetti attraverso la lettura mirata del codice. Un prerequisito per questa metodologia di verifica è la definizione di una lista di controllo che elenca le possibili sezioni o passaggi maggiormente soggetti ad errori. La verifica deve essere condotta da soggetti nettamente distinti dai programmatori. La correzione degli errori individuati va eseguita in ogni fase e documentata tramite un rapporto delle attività svolte;

\item \textbf{Walkthrough}: l'obiettivo di questa tecnica di analisi è l'individuazione di difetti eseguendo una lettura integrale di tutto il codice senza l'assunzione di presupposti. Viene eseguita da gruppi misti di ispettori e sviluppatori.
Per evitare incomprensioni è importante che al termine della lettura gli elementi coinvolti discutano i difetti trovati e che nessuna persona possa coprire entrambi i ruoli allo stesso tempo.
Al termine della fase di discussione si applicherà la fase di correzione dei difetti che apporterà le modifiche concordate. 
Anche in questo caso è importante tenere un rapporto delle attività svolte.
\end{itemize}

\item \textbf{Analisi dinamica}: consiste nel verificare e validare il software o un suo componente osservandone il comportamento in esecuzione durante lo svolgimento di test. Tali test devono essere svolti in maniera ripetibile: significa che se eseguiti nello stesso ambiente e con gli stessi ingressi, devono produrre i medesimi risultati.
\begin{itemize}
\item \textbf{Test di unità}: esamina la correttezza di piccole unità di codice, generalmente prodotte da un singolo programmatore, in modo da verificare che esse rispettino i loro requisiti. È possibile svolgerlo con un alto grado di parallelismo possibilmente servendosi di un automa.

\item \textbf{Test di integrazione}: verifica che l'integrazione delle unità che hanno superato il test precedente non produca problemi. Tali problemi, non potendo essere relativi alle singole unità, saranno da ricercare nell'interfaccia che le aggrega.

\item \textbf{Test di sistema}: accerta la copertura dei requisiti software individuati nell'analisi dei requisiti permettendo la validazione del sistema prodotto.

\item \textbf{Test di regressione}: stabilisce se modifiche all'implementazione di un programma alterano elementi precedentemente funzionanti. Per far ciò si eseguono nuovamente i test di unità e integrazione sulle parti modificate.

\item \textbf{Test funzionali}: mettono alla prova le funzionalità del sistema, simulando l'iterazione tra Utente e sistema.

\item \textbf{Test Prestazionali}: valutano le prestazioni dell'applicazione in molti modi e da molti punti di vista. Questo tipo di test mostra ciò che proverà l'utente in termini di caricamento e velocità del sito. Le prestazioni sono importanti anche per motivi SEO, in quanto un sito lento verrà analizzato molto meno frequentemente dai web crawler dei motori di ricerca.

\item \textbf{Test di collaudo}: attività formale supervisionata dal committente il cui buon esito comporta la possibilità di rilasciare il prodotto.
\end{itemize}
\end{itemize}
\subsubsection{Metodi}
\label{sec:Metodi}
Il gruppo ha deciso di utilizzare i seguenti metodi per applicare le tecniche sopra descritte, aiutandosi con gli strumenti elencati:
\begin{itemize}
\item \textbf{Documenti \LaTeX}:
\begin{enumerate}
\item rilettura approfondita;
\item controllo ortografico tramite lo strumento Aspell;
\item controllo dell'applicazione delle regole tipografiche esposte nel documento Norme di progetto;
\item verifica della corretta formattazione del file pdf prodotto.
\end{enumerate}

\item \textbf{Codice}: il codice verrà analizzato dagli strumenti integrati all'interno dell'IDE Aptana e dagli strumenti di sviluppo forniti dai singoli browser.

\item \textbf{Schemi UML}:
\begin{enumerate}
	\item data l'impossibilità di controllare la correttezza ortografica degli schemi, con Aspell è necessario esaminare attentamente e più volte i nomi, gli identificativi e i testi nei diagrammi;
	\item controllo della correttezza degli identificativi dei casi d'uso rispetto alla nomenclatura stabilita nel documento Norme di Progetto e rispetto alle sezioni dell'Analisi dei Requisiti in cui sono inseriti;
	\item controllo della numerazione dei casi d'uso rispetto la loro gerarchia;
	\item controllo che i casi d'uso soddisfino tutte le esigenze espresse nel capitolato.
\end{enumerate}
\end{itemize}
\subsubsection{Metriche}
Una metrica è la misura di una qualche proprietà relativa ad una porzione di software allo scopo di fornire informazioni significative sulla qualità del codice prodotto.
Non bisogna tuttavia basarsi solamente sulle metriche, che sono solo indicatori a posteriori della bontà del lavoro svolto: un'importanza ancora maggiore la riveste il controllo sulla qualità del processo.
\begin{itemize}
\item \textbf{Complessità Ciclomatica di McCabe}: è indicazione del numero di segmenti lineari in un metodo (ad esempio sezioni di codice senza ramificazioni), può quindi essere usato per determinare il numero di test necessari per ottenere una copertura completa dei possibili cammini. 
Un metodo senza ramificazioni ha Complessità Ciclomatica di McCabe pari a 1; tale valore è incrementato ogni qualvolta si incontra una ramificazione. 
Con “ramificazione” si intendono cicli, costrutti “if” e simili;

\item \textbf{Numero di istruzioni}: rappresenta il numero di istruzioni all'interno di un metodo. 
Un indice elevato non rappresenta necessariamento un cattivo codice ma suggerisce la possibilità di estrarre metodi contenenti gruppi di istruzioni correlate, aumentando il livello di astrazione;

\item \textbf{Indice di mantenibilità}: calcola un indice dal valore compreso tra 0 e 100 che rappresenta la facilità di mantenibilità del codice. 
Un elevato valore indica un'ottima mantenibilità: un punteggio tra 20 e 100 indica che il codice ha mantenibilità buona; tra 10 e 19, una manteniblità moderata; un punteggio tra 0 e 9 indica bassa mantenibilità.

\item \textbf{Copertura del codice}: è indicazione di quanto codice sorgente sia stato testato. Un elevato indice di copertura indica che il codice sorgente è stato testato in profondità e che difficilmente può contenere dei bug.

\end{itemize}
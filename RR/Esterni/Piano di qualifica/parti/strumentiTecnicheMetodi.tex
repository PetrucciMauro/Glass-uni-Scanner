
\subsection{Strumenti,tecniche e metodi}

\subsubsection{Strumenti}
\label{sec:strumenti}
Di seguito verranno elencati gli strumenti software che sono o saranno utilizzati dal gruppo per effettuare le operazioni di verifica e validazione:
\begin{itemize}

\item \textbf{Aspell}: correttore ortografico per documenti redatti in \LaTeX;

\item \textbf{Aptana}: scelto dal gruppo per la stesura del codice ha integrato al suo interno varie funzioni di debugging ed esecuzione del codice;

\item \textbf{W3C validator}: Sito che controlla la validità dei markup nei documenti scritti in HTML;

\item \textbf{Jenkins} : sistema di per l'integrazione continua del codice e dei file latex;

\item \textbf{jSHint}  : tool di supporto per la ricerca di eventuali errori nel codice javascript;

\item \textbf{Selenium IDE} : esentione di Firefox che permette di registrare test tramite browser;

\item \textbf{ApacheBrench} : strumento a linea di comando utilizzato per misurare l’efficienza di un server web ed in grado di simulare situazioni di
sovraccarico della rete;

\item \textbf{SpeedTracer} : plugin per Google Chrome che permette di verificare l’efficienza di un’applicazione web durante la sua esecuzione.

Verranno utilizzati anche tutti gli strumenti già integrati all'interno del browser per lo sviluppo delle pagine web.

\end{itemize}
\subsubsection {Tecniche}
\begin{itemize}
\item \textbf{Analisi statica}: consiste nell’analizzare il codice tramite tools e letture senza tuttavia eseguirlo. Data la natura di questo tipo di analisi, è possibile applicarla anche per il controllo di tutti i documenti testuali prodotti.
Si esegue applicando i due seguenti metodi:
\begin{itemize}
\item \textbf{Inspection}: l’obiettivo di questa tecnica di analisi è l’individuazione di
difetti attraverso la lettura mirata del codice. Un prerequisito per questa metodologia di verifica è la definizione di una lista di controllo che
elenca le possibili sezioni o passaggi maggiormente soggetti ad errori.  verifica deve essere condotta da soggetti nettamente distinti dai programmatori. La correzione degli errori individuati va eseguita in ogni fase e documentata tramite un rapporto delle attività svolte;

\item \textbf{Walkthrough}: l'obiettivo di questa tecnica di analisi è l'individuazione di difetti eseguendo una lettura integrale di tutto il codice senza l'assunzione di presupposti. Viene eseguita da gruppi misti di ispettori e sviluppatori.
Per evitare incomprensioni è importante che al termine della lettura gli elementi coinvolti discutano i difetti trovati e che nessuna persona possa coprire entrambi i ruoli allo stesso tempo.
 Al termine della fase di discussione si applicherà la fase di correzione dei difetti che apporterà le modifiche concordate. 
Anche in questo caso è importante tenere un rapporto delle attività svolte.
\end{itemize}

\item \textbf{Analisi dinamica}: consiste nel verificare e validare il software o un suo componente osservandone il comportamento in esecuzione durante lo svolgimento di test. Tali test devono essere svolti in maniera ripetibile ossia devono venir eseguiti nello stesso ambiente e con gli stessi ingressi in modo da potersi  aspettare i medesimi risultati.
\begin{itemize}
\item \textbf{Test di unità}: esamina la correttezza di piccole unità di codice, generalmente prodotte da un singolo programmatore, in modo da verificare che esse rispettino i loro requisiti. E' possibile svolgerlo con un alto grado di parallelismo possibilmente servendosi di un automa.

\item \textbf{Test di integrazione}:
verifica che l'integrazione delle unità che hanno superato il test precedente non produca problemi. Tali problemi, non potendo essere relativi alle singole unità, saranno da ricercare nell'interfaccia che le aggrega.
\item \textbf{Test di sistema}:
accerta la copertura dei requisiti software individuati nell'analisi dei requisiti permettendo la validazione del sistema prodotto

\item \textbf{Test di regressione}:
stabilisce se modifiche all'implementazione di un programma alterano elementi precedentemente funzionanti. Per far ciò si eseguono nuovamente i test di unità e integrazione sulle parti modificate.

\item \textbf{Test funzionali}:
Mettono alla prova le funzionalità del sistema ,simulando l'iterazione tra Utente e sistema.

\item \textbf{Test Prestazionali}:
Valuta le prestazioni dell'applicazione in molti modi e da molti punti di vista. Questo tipo di test mostra ciò che proverà l'utente in termini di caricamento e velocità del sito. Le prestazioni sono importanti anche epr motivi SEO , in quanto un sito lento verrà analizzato molto meno frequentemente dai search engine crawlers dei motori di ricerca ;

\item \textbf{Test di collaudo}:
attività formale supervisionata dal committente il cui buon esito comporta la possibilità di rilasciare il prodotto.
\end{itemize}
\end{itemize}
\subsubsection{Metodi}

Il gruppo ha deciso di utilizzare i seguenti metodi per applicare le tecniche sopra
descritte, aiutandosi con gli strumenti elencati:
\begin{itemize}
\item \textbf{Documenti \LaTeX}:
\begin{enumerate}
\item rilettura approfondita;
\item controllo ortografico tramite lo strumento Aspell;
\item controllo dell'applicazione delle regole tipografiche esposte nel documento Norme di progetto;
\item verifica della corretta formattazione del file pdf prodotto.
\end{enumerate}

\item \textbf{Codice}:
 
il codice verrà analizzato dagli strumenti integrati all'interno dell' IDE Aptana e dagli strumenti di sviluppo forniti dai singoli browser .

\item \textbf{Schemi UML}:
\begin{enumerate}


\item data l'impossibilità di controllare la correttezza ortografica degli schemi;
con Aspell è necessario esaminare attentamente e più   volte i nomi, gli identificativi e i testi nei diagrammi;
\item controllo della correttezza degli identificativi dei casi d'uso rispetto alla nomenclatura stabilita nel documento Norme di progetto e rispetto alle sezioni dell'Analisi dei requisiti in cui sono inseriti;
\item controllo della numerazione dei casi d'uso rispetto la loro gerarchia;
\item controllo che i casi d'uso soddisfino tutte le esigenze espresse nel capitolato.
\end{enumerate}
\end{itemize}
\subsubsection{Metriche}

Una metrica è una misura di una qualche proprietà relativa ad una porzione di
software , allo scopo di fornire informazioni significative sulla qualità del codice
prodotto. Non bisogna tuttavia basarsi solamente sulle metriche, che sono solamente
indicatori a posteriori della bontà del lavoro svolto: un'importanza ancora maggiore
la riveste il controllo sulla qualità del processo.
\begin{itemize}


\item \textbf{Complessità  ciclomatica di McCabe}: è un'indicazione del numero di segmenti lineari in un metodo (ad esempio sezioni di codice senza ramificazioni) e quindi può essere usato per determinare il numero di test necessari per ottenere una copertura completa dei possibili cammini. Un metodo senza ramificazioni ha Complessità Ciclomatica pari a 1. Tale valore è incrementato ogni qualvolta si incontra una ramificazione. Con “ramificazione” si intendono i cicli e i costrutti “if” e simili.

\item \textbf{Numero di istruzioni}: numero di istruzioni all'interno di un metodo. Un
indice elevato non rappresenta necessariamento un cattivo codice ma suggerisce la possibilità di estrarre metodi contenenti gruppi di istruzioni correlate, aumentando il livello di astrazione

\item \textbf{Indice mantenibilità}:Calcola un indice dal valore compreso tra 0 e 100 che rappresenta la facilità di mantenibilità del codice. Un elevato valore indica una ottima mantenibilità. Un punteggio tra 20 e 100 and indica che il codice ha buona mantenibilità . Un punteggio tra 10 e 19 indica che il codice ha una moderata manteniblità. un punteggio tra 0 e 9 indica una bassa mantenibilità.

\item \textbf{Copertura del codice}:  è un indicazione di quanto codice sorgente è stato testato . un elevato indice di copertura indica che il codice sorgente è stato testato in profondità e che difficilmente può contenere dei bug .

\end{itemize}
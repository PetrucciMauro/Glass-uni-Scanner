\section{Visione generale della strategia di verifica}{
	\subsection{Organizzazione}{
		Allo scopo di garantire la qualità del prodotto in tutte le sue fasi di realizzazione, accertandone la conformità rispetto a 
		quanto emerso durante l'attività di Analisi dei Requisiti ($\AnalisiDeiRequisiti$), si intende svolgere una costante 
		verifica attraverso tutte le fasi di sviluppo del progetto. È infatti impensabile prevedere la verifica solo alla fine del lavoro, 
		rischiando di dover rifare o ripensare alcune componenti.\\
		Le operazioni di controllo verranno istanziate quando il prodotto da analizzare avrà raggiunto uno stato per cui presenti 
		differenze sostanziali rispetto allo stato precedente; grazie al registro delle modifiche le verifiche saranno circoscritte 
		ai soli cambiamenti permettendo di ottimizzare il tempo e le risorse impiegate.\\
		L'approccio scelto per la correzione delle anomalie è quello del "\textit{Broken Windows Theory}", secondo il quale ogni difetto 
		individuato va corretto immediatamente onde evitarne il propagarsi all'interno del progetto.\\
		I processi di verifica dovranno essere il più automatizzati possibile in modo tale da garantirne la ripetibilità e l'efficienza.
		Il modello di ciclo di vita scelto è quello incrementale ($\PianoDiProgetto$).

		L’obiettivo delle attività di verifica è quello di trovare e rimuovere i problemi presenti. Un problema può verificarsi a vari 
		livelli, e per ogni livello assume un nome diverso:
		\begin{itemize}
			\item \textbf{fault (difetto)}: è l’origine del problema, il difetto che fa scaturire il malfunzionamento;
			\item \textbf{error (errore)}:  è lo stato per cui il software$_{|g|}$ si trova in un punto sbagliato del flusso di 
			      esecuzione o con valori sbagliati rispetto a quanto previsto dalla specifica;
			\item \textbf{failure (fallimento, guasto)}: è un comportamento difforme dalla specifica, cioè la manifestazione 
			      dell’errore all’utente del software$_{|g|}$.
		\end{itemize}
		Esiste una relazione di causa-effetto fra questi tre termini:
		\begin{center}
			DIFETTO $\longrightarrow$ ERRORE $\longrightarrow$ FALLIMENTO
		\end{center}
		Non sempre un errore dà origine ad un fallimento: ad esempio potrebbero esserci alcune variabili che si trovano in stato erroneo 
		ma non vengono lette, o non viene percorso il ramo di codice che le contiene. È  necessario prestare particolare attenzione a 
		questo tipo di errori (detti anche quiescenti), avvalendosi anche di strumenti per il rilevamento dei bug$_{|g|}$ come FindBugs.

		\subsection{Pianificazione strategica e generale}{
		\label{commint}
		Il processo di verifica viene strutturato in tre fasi:
		\begin{enumerate}
		    \item \textbf{Attività di pre-verifica}: riguardano la pianificazione e la preparazione delle attività di verifica. 
			  Consistono nella scelta delle persone che si occuperanno della verifica e nella distribuzione dei documenti o componenti 
			  software$_{|g|}$ da controllare. I verificatori lavorano indipendentemente per trovare errori, omissioni e scostamenti 
			  rispetto agli standard previsti.
		    \item \textbf{Incontro di verifica}: durante questa fase, un autore del documento o componente software$_{|g|}$ rivede 
			  l’oggetto dell’analisi con il Verificatore. Deve essere annotato un elenco delle azioni correttive concordate 
			  durante l’incontro. Verranno usate diverse checklist per diverse aree di verifica 
			  (documentazione, vari linguaggi di programmazione, etc.).
		    \item \textbf{Attività di post-verifica}: i problemi emersi dall’incontro di verifica devono essere risolti. Questo può 
			  includere la correzione di bug$_{|g|}$ e la riscrittura di alcune parti di codice o di documenti. La persona che apporta 
			  i cambiamenti deve controllare che tutti i punti inseriti nell’elenco redatto al punto precedente siano stati coperti. 
			  Talvolta potrebbe essere richiesta una nuova verifica per accertarsi che le correzioni effettuate 
			  corrispondano alle richieste di modifica.
		\end{enumerate}

		Durante le attività di verifica è inevitabile che gli errori commessi dagli individui vengano esposti a tutto il gruppo. 
		\`E quindi molto importante che si sviluppi una mentalità per la quale la segnalazione degli errori non diventi motivo di 
		screditamento per l’individuo, ma occasione di crescita per l’intero gruppo di progetto.\\
		Verranno di seguito illustrate le modalità di verifica riguardanti le diverse fasi del progetto.
	}

	\subsubsection{Verifica della documentazione}{
		\label{sec:VerificaDocs}
		 Viene svolta mediante due tecniche:
		\begin{itemize}
		      \item \textbf{Walkthrough}: è un processo informale, non pianificato, che non richiede preparazione ma è molto dispendioso. 
			    Consiste nella rilettura completa del deliverable$_{|g|}$ da parte dell'autore stesso o da parte del Verificatore allo 
			    scopo di trovare errori e ogni modifica da apportare viene discussa. Nonostante il dispendio di tempo e risorse che comporta 
			    questa tecnica, essa si rende indispensabile all’inizio delle diverse fasi di progetto per la correzione dei difetti. 
			    Al fine di ridurre l’utilizzo di questa tecnica nelle fasi più avanzate, a favore della più efficiente inspection (definita 
			    nel prossimo punto), ogni problematica individuata dovrà essere aggiunta a una lista di controllo.
		      \item \textbf{Inspection}: è un processo formale, volto all’individuazione di errori da ricercare in parti ritenute critiche in base all’esperienza 
			    precedentemente accumulata attraverso le revisioni. La lista di problematiche da ricercare viene definita gradualmente durante la fase di 
			    walkthrough e va a comporre una lista di controllo. L’inspection è da preferire al walkthrough, ma richiede un sufficiente livello di dettaglio nella lista di 
			    controllo.\\
			    Riguardo all'attività di verifica della documentazione, elenchiamo di seguito i punti da controllare.
			    Per le parti scritte in \LaTeX:
			    \begin{itemize}
				\item presenza dello spazio dopo un segno di punteggiatura;
				\item assenza dello spazio dopo la parentesi aperta, prima della parentesi chiusa, all’inizio e alla fine delle virgolette e degli apici;
				\item corretto uso della punteggiatura, soprattutto negli elenchi puntati e numerati;
				\item corretto utilizzo delle lettere maiuscole o minuscole negli elenchi puntati e numerati;
				\item assenza di parti di documento da definire marcate da sequenze come “Aggiungere”;
				\item funzionamento dei link interni ed esterni al documento (assenza della sequenza '??' generata da \LaTeX in questi casi);
				\item corretta sillabazione alla fine delle righe;
				\item assenza di termini definiti nel glossario e non contrassegnati da simbolo $_{|g|}$, con sottolineatura per i termini formati da più parole;
				\item didascalie coerenti con l'immagine a cui si riferiscono;
				\item corretto posizionamento delle immagini;
				\item assenza di errori di battitura (tramite Aspell) e corretto utilizzo degli accenti.
			    \end{itemize}
			    Per una trattazione completa delle caratteristiche che un documento deve possedere, si rimanda al documento $\NormeDiProgetto$.
		\end{itemize}
	}

	\subsubsection{Analisi dei Requisiti}{
		La verifica inizia quando i documenti:
			\begin{itemize}
				\item piano di progetto
				\item norme di progetto
				\item analisi dei requisiti
				\item studio di fattibilità
				\item piano di qualifica
			\end{itemize}
		hanno una struttura definita e sufficienti contenuti su cui poter verificare.
		La verifica avviene mediante controllo ortografico, grammaticale e concettuale dei documenti da consegnare alla prima revisione; 
		in caso ci fossero problemi il Verificatore dovrà comportarsi come descritto nel documento \textit{\NormeDiProgetto}.
		Il Verificatore deve accertarsi della correttezza logica e formale dei requisiti, della loro tracciabilità, non ambiguità e
		conformità con quanto richiesto dal \textit{Proponente}. Il tracciamento dei requisiti si avvia con la fase di analisi dei 
		requisiti e permane fino alla fase di codifica. Il suo scopo è quello di evidenziare le relazioni tra i requisiti emersi e ciò 
		che è stato prodotto nelle varie fasi al fine di garantire lo sviluppo di un prodotto finale che soddisfi tutti i requisiti 
		individuati in partenza.\\
		Viene rivolta particolare attenzione ai casi d’uso, che sono la fonte principale di errori di vario tipo: essi devono possedere un 
		codice identificativo univoco e un titolo non ambiguo e sufficientemente descrittivo. Inoltre, gli attori devono avere 
		l’indicazione del ruolo svolto nel particolare caso d’uso. Ogni caso d’uso è associato ad uno o più requisiti. 
		Viene effettuata una prima verifica che controlla che ciascun ingresso di una fase venga messo in relazione con una specifica 
		uscita in quella fase.\\
		Un'ulteriore fonte di errore è l’uso scorretto degli exend per modellare le condizioni. La soluzione sarà quella di minimizzarli.\\
		Nel caso in cui vengano riscontrati errori il Verificatore avrà cura di segnalarli al redattore del documento, il quale dovrà 
		apportare le modifiche richieste e ripresentare il documento stesso per un'ulteriore attività di verifica ed eventuale validazione.
		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaDocumenti.pdf}
			\caption{Verifica dei documenti}
		      % \label{fig:VerificaDocumenti}
		\end{figure}

	}
	
	\subsubsection{Progettazione architetturale}{
		Lo scopo del processo di verifica consiste nell'accertarsi che ogni requisito evidenziato in sede di analisi sia tracciabile 
		nei componenti individuati in sede di progettazione e che ogni componente soddisfi almeno un requisito.
		Durante questa attività sarà scopo del gruppo il perseguimento delle seguenti proprietà:
		\begin{itemize}
		    \item \textbf{semplicità}: i componenti devono contenere solo quello che è necessario al loro funzionamento;
		    \item \textbf{incapsulamento}: il funzionamento interno di una classe viene nascosto all'esterno, proteggendo 
			  così gli utenti di quella classe da eventuali modifiche. Per ottenere ciò è necessario progettare robuste 
			  interfacce per le classi;
		    \item \textbf{coesione}: misura quanto sono collegati tra di loro le componenti di un modulo$_{|g|}$. Se i metodi 
			  di una classe svolgono compiti simili, il grado di coesione di tale classe è alto. 
			  L'obiettivo sarà quello di massimizzare questo aspetto;
		    \item \textbf{accoppiamento}: indica quanto una componente fa affidamento sull'altra, dipendendo da essa. 
			  Un basso grado di accoppiamento favorisce la manutenibilità del software$_{|g|}$.
		\end{itemize}
		Gli obiettivi di qualità vengono descritti nell'appendice A (cap. \ref{sec:Qualita2}).
		Il verificatore effettua una verifica incrociata tra i requisiti riportati nel documento \textit{\AnalisiDeiRequisiti} 
		e le componenti descritte nel documento \textit{\SpecificaTecnica}, per accertare che le componenti architetturali prodotte 
		durante la progettazione ad alto livello e i metodi e gli attributi prodotti nella progettazione di dettaglio soddisfino 
		i requisiti utente. Le attività di tracciamento, controllo diagrammi UML$_{|g|}$ e verifica della progettazione vengono 
		eseguite in parallelo assicurando il soddisfacimento delle quattro proprietà descritte sopra. 
		Inoltre, i verificatori devono controllare che:
		\begin{itemize}
			\item le componenti del sistema non siano eccessivamente complesse;
			\item non sia possibile decomporre ulteriormente le parti individuate;
			\item i pattern siano usati correttamente;
		\end{itemize}
	    
		I diagrammi UML$_{|g|}$ devono possedere le seguenti proprietà:
		\begin{itemize}
			\item seguire le specifiche descritte in \textit{\NormeDiProgetto};
			\item conformità allo standard 2.0;
			\item correttezza tra associazioni;
			\item complessità non eccessiva: se è possibile individuare dei gruppi logici indipendenti in uno stesso diagramma, 
			      allora la complessità è troppo elevata. Ciò è causa di errori, diminuisce la comprensibilità e riduce il 
			      tempo di vita del diagramma stesso, in quanto una delle componenti rappresentate potrebbe essere soggetta 
			      a cambiamenti;
			\item le relazioni di dipendenza devono essere corrette;
			\item le classi devono essere posizionate correttamente (al posto giusto e nel package$_{|g|}$ giusto).
		\end{itemize}
		I pattern utilizzati devono essere descritti e motivati, specificando i vantaggi e le implicazioni derivanti dalla loro adozione.
		\newpage
		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaProgettazione.pdf}
			\caption{Verifica della progettazione}
		      % \label{fig:VerificaProgettazione}
		\end{figure}

		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaAR.pdf}
			\caption{Sottoattività 1: Verifica dell'Analisi dei Requisiti}
		      % \label{fig:VerificaAR}
		\end{figure}
		\newpage

		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaST.pdf}
			\caption{Sottoattività 2: Verifica della Specifica Tecnica}
		      % \label{fig:VerificaST}
		\end{figure}

		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaDiagrammiUML.pdf}
			\caption{Sottoattività 3: Verifica dei diagrammi UML}
		      % \label{fig:VerificaDiagrammiUML}
		\end{figure}
	}

	\subsubsection{Programmazione di dettaglio e codifica}{
		Parallelamente all'attività di progettazione di dettaglio viene portata avanti la codifica, che deve essere accompagnata 
		da test sul codice prodotto non appena questo è pronto. Devono essere effettuati test di unità, scritti dai
		programmatori stessi, per verificare che il comportamento del codice che hanno scritto corrisponda a quanto ci si aspetta. 
		Un test su un'unità è composto da:
		\begin{itemize}
			\item [-] l’oggetto su cui viene eseguito il test;
			\item [-] la strategia utilizzata per effettuare la prova;
			\item [-] le risorse software$_{|g|}$ necessarie;
			\item [-] il piano di esecuzione del test stesso, che deve prevedere gli ingressi e le uscite attese del test.
		\end{itemize}
		\`E necessario che i test pianificati assicurino le seguenti due proprietà al fine di individuare gli errori:
		\begin{itemize}
			\item \textbf{Statement coverage}: il test deve coprire tutte le linee di codice del modulo sotto esame;
			\item \textbf{Branch coverage}: il test deve coprire tutti i rami del flusso di controllo almeno una volta;
		\end{itemize}
		Tali test saranno di tipo white box: si entra in dettaglio sul codice sorgente delle singole unità analizzando come, 
		a partire dagli input, gli output sono prodotti. Si verifica così la correttezza logica di ogni metodo.\\
		I verificatori dovranno poi eseguire un’attività di inspection su quanto scritto dai programmatori secondo la seguente 
		lista di controllo:
		\begin{itemize}
			\item le variabili globali non sono ammesse;
			\item le variabili vanno inizializzate al momento della dichiarazione;
			\item i nomi delle variabili, delle classi e dei metodi devono rispettare le \textit{\NormeDiProgetto};
			\item non sono ammesse variabili e metodi non utilizzati;
			\item minimizzare, se non eliminare, la presenza di warning$_{|g|}$; l'uso del \texttt{break}$_{|g|}$ non è ammesso 
				  se non all'interno dei costrutti \texttt{switch}$_{|g|}$, che vanno minimizzati in quanto aumentano la 
				  complessità ciclomatica di 1 per ogni \texttt{case};		
			\item le variabili che controllano l'uscita dai cicli non devono poter essere modificate dall'esterno del ciclo;
			\item la derivazione della classi non deve essere abusata al fine di evitare ambiguità sull'overriding$_{|g|}$ 
				  di metodi;
			\item deve essere favorita la \underline{lazy evaluation}$_{|g|}$ delle condizioni booleane;
			\item il codice deve essere il più possibile comprensibile; qualora risulti di difficile comprensione il 
			      programmatore deve inserire dei commenti. I commenti non vanno tuttavia inseriti per descrivere righe 
			      il cui significato è ovvio;
			\item l'indentazione deve essere consistente e favorire la lettura del codice.
		\end{itemize}
		Lo stile di codifica deve comunque essere conforme a quanto specificato nel documento \textit{\NormeDiProgetto}. 
		Vanno infine garantite le caratteristiche di qualità descritte dallo standard ISO/IEC 9126 e riportate in appendice A.2  e il 
		rispetto dei valori per le metriche stabiliti nel presente documento (cap. \ref{sec:Metriche}).\\
		La verifica durante l'attività di codifica verrà effettuata dai Programmatori, che dovranno scrivere il codice del test sui 
		metodi da loro prodotti. \`E inoltre responsabilità dei Programmatori lo svolgimento dei test di unità e il rispetto 
		degli obiettivi di qualità elencati nella sezione Qualità (cap. \ref{sec:Qualita}).

		\begin{figure}[h!]
			\centering
			\includegraphics[scale=.7]{\docsImg VerificaCodifica.pdf}
			\caption{Verifica della codifica}
		      % \label{fig:VerificaCodifica}
		\end{figure}
	}
	\subsection{Test di integrazione}{
		Quando è terminata la fase di sviluppo e testing di unità che dovranno essere integrate, si procede all'integrazione 
		(aggiungendo il codice necessario) e al successivo test di integrazione, senza attendere che vengano ultimati i test su
		tutte le unità, al fine di ottimizzare i tempi. Tale test ha lo scopo di verificare che le componenti interagiscano 
		nella maniera desiderata.\\
		Il modello di sviluppo scelto è di tipo top-down$_{|g|}$, che prevede che la realizzazione delle componenti di livello 
		più alto preceda quella delle componenti di livello più basso; sarà quindi disponibile in breve tempo uno scheletro del 
		sistema. Gli errori individuati sono pertanto da imputare all'aggiunta dell'ultima componente, rendendo l'attività di 
		testing un'attività incrementale. I test di integrazione sono di tipo black-box. 
		I test devono essere contraddistinti da un ID, devono elencare le componenti in esame e le modalità di testing.
		Nell'appendice \ref{sec:testI} vengono elencati i test di integrazione svolti dal gruppo per lo sviluppo di \textbf{MyTalk}.
	}
	\subsubsection{Validazione}{
		
		Quando tutte le componenti sono state testate e integrate si procede con il test di sistema, che controlla che il prodotto
		svolga correttamente i suoi compiti e rispetti i requisiti fissati in sede di analisi.\\
		Il controllo di sistema si divide in due categorie:
		\begin{itemize}
			\item \textbf{alfa-test}: effettuato all'interno del gruppo, consiste nell'utilizzo del software$_{|g|}$, 
			      andando a testare	tutte le funzionalità e inserendo istruzioni di controllo a tempo di esecuzione, 
			      segnalando eventuali malfunzionamenti;
			\item \textbf{beta-test}: consiste in un utilizzo normale del prodotto, alla ricerca degli ultimi problemi residui.
		\end{itemize}
		\textit{GoGo Team} si impegna a garantire il corretto funzionamento del prodotto software$_{|g|}$ realizzato. 
		Nel caso in cui vengano riscontrate anomalie o discrepanze tra le caratteristiche del prodotto e le richieste del cliente 
		sarà cura del fornitore eliminare tali difetti, interamente a proprio carico.
	}
    }
    
    \subsection{Responsabilità}{
	La responsabilità dell'attività di verifica viene affidata ai seguenti ruoli:
	\begin{itemize}
	    \item Responsabile: controlla che l'evoluzione del progetto rispetti le tempistiche prefissate ed è garante della qualità dei 
		  processi interni;
	    \item Verificatore: segue le strategie di analisi concordate e si occupa della parte di verifica, segnalando formalmente gli errori
		  riscontrati.
	\end{itemize}

    }

    Gli strumenti, le tecniche e i metodi di verifica vengono descritti nel documento \textit{\NormeDiProgetto}.
}
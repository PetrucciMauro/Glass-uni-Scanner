%
% LEGGERE
% \texttt{} ha l'effetto collaterale che non manda a capo la parola, che quindi sfora la riga.
% Per evitarlo, usare \path{} per i percorsi lunghi. \path{} va a capo quando incontra un punto
% (quindi in mytalk.presenter va a capo al punto).
% Sembrerebbe che \path{} fosse la panacea di tutti i mali, ma ha il difetto che ignora gli spazi
% (giustamente, un path non contiene spazi).
% Per i nomi di metodi qualificati (quindi completi di package), usare \path{} fino alla lista dei
% parametri, poi usare \texttt{}.
%

\section{Test di Unità}{
	\begin{sloppypar} % impedisce al testo di sforare il limite destro, che altrimenti sfora con il testo in monospace
	Di seguito sono riportati gli esiti dei test di unità effettuati per verificare la correttezza logica dei singoli metodi. I package sottoposti a tale verifica sono quelli riguardanti il Presenter e il Model. \\
L'interfaccia grafica, invece, sarà sottoposta ai soli test di sistema poiché è risultato impossibile istanziare gli oggetti delle classi grafiche da testare all'interno del framework GWT, anche utilizzando la classe GWTTest, utilizzata per la verifica di alcune classi del Presenter.

	\subsection{Presenter}{
		L'obiettivo di questi test è quello di verificare il corretto funzionamento della logica dei metodi delle classi che compongono il Presenter. Per l’esecuzione dei test sono state utilizzati i seguenti framework\g~ di testing:
		\begin{itemize}
			\item[•] JUnit 4: permette di scrivere ed eseguire in modo automatizzato i \underline{test case}\g~;
			\item[•] Mockito 1.9.5: permette di simulare oggetti appartenenti a classi esterne a quella testata ed utilizzati da quest’ultima;
			\item[•] GWT Test Utils 0.35: permette di accedere alle funzionalità offerte dal framework\g~ Google Web Toolkit, altrimenti non utilizzabili tramite semplici test JUnit. In particolare, si vuole controllare la corretta gestione dei cookie\g~.
		\end{itemize}
		
		\subsubsection{Package mytalk.client.model.localDataUser}{
			
			% ManageCookies - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.model.localDataUser.ManageCookies}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.client.model.localDataUser.ManageCookiesTest}

					\item[] \textbf{Descrizione:} \\ Verifica la corretta creazione, lettura e distruzione dei cookie\g~.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testCreateSessionCookie()}: viene creato il cookie\g~ richiamando il metodo \texttt{createSessionCookie()} e ne viene verificata l’effettiva creazione richiamando il metodo della classe \texttt{Cookies} di \texttt{GWT} \texttt{getCookie()}.
						
						\item \texttt{testGetCookieUsername()}: vengono creati due cookie\g~, uno con contenuto vuoto e uno con la stringa \texttt{“username@email.it”}, e si verifica che il metodo \texttt{getCookieUsername()} ritorni il contenuto corretto. Viene infine testato il caso in cui il cookie\g~ non esista, controllando che il valore di ritorno di \texttt{getCookieUsername()} sia \texttt{null}.

						%\item \texttt{testGetCookieAdmin()}: vengono creati due cookie\g~, uno con contenuto vuoto e uno con la stringa \texttt{“administrator@email.it”}, e si verifica che il metodo \texttt{getCookieAdmin()} ritorni il contenuto corretto. Viene infine testato il caso in cui il cookie non esista, controllando che il valore di ritorno di \texttt{getCookieAdmin()} sia \texttt{null}.

						\item \texttt{testGetCookieIP()}: viene creato un cookie\g~ con un indirizzo IP\g~ come contenuto e si verifica che il metodo \texttt{getCookieIP()} ritorni l'indirizzo corretto.

						\item \texttt{testDeleteCookies()}: viene creato un cookie\g~ tramite il metodo \texttt{createSessionCookie(String name, String, content)} e ne viene verificata la corretta creazione utilizzando il metodo \texttt{getCookie(String name)}, entrambi offerti dalla classe \texttt{Cookies} di \texttt{GWT}. Successivamente, viene richiamato il metodo  \texttt{deleteCookies()} della classe \texttt{ManageCookies} per eliminare il cookie\g~ creato e ne viene verificata l’effettiva eliminazione controllando che il metodo \texttt{getCookie(String name)} ritorni un riferimento nullo.
					\end{itemize}
					\item[] \textbf{Stato:} {Superato}

					\item[] \textbf{Bug individuati:} {0}
				\end{itemize}	
			\end{itemize}
			% ManageCookies - fine
		}
			
		\subsubsection{Package mytalk.client.presenter.user.logicUser}{
			% DataUserLogic - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.presenter.user.logicUser.DataUserLogic}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:}	\\ \path{mytalk.client.presenter.user.logicUser.DataUserLogicTest}

					\item[] \textbf{Descrizione:} {\\Viene controllato che la classe:
						\begin{itemize}
							\item modifichi i dati nel nodo esatto;
							\item restituisca opportuni messaggi di errore;
							\item comunichi correttamente con le classi \texttt{WebSocket} e \texttt{UpdateViewLogic}.
						\end{itemize}
						Prima di iniziare il test, vengono creati due vettori, uno con dati corretti e uno con dati sbagliati.
					}
					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testCheckNewData()}: viene richiamato più volte il metodo da testare \texttt{checkNewData(Vector<String> input)} con diverse combinazioni, corrette ed errate, di dati nel vettore passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua. Ad ogni invocazione, viene controllato che il valore del campo dati \texttt{loginOk} corrisponda a quanto atteso.
						
						\item \texttt{testLogoutUser()}: viene inizialmente creato un cookie\g~ per simulare una sessione attiva, successivamente viene richiamato il metodo \texttt{logoutUser()} e si controlla che invochi correttamente il metodo \path{mytalk.client.presenter.client.user.serverComUser.logoutUser(String}  \texttt{data)}, con la stringa uguale al contenuto del cookie\g~. Si verifica poi l'invocazione dei metodi \path{mytalk.client.presenter.user.logicUser.removeCookies()} e \path{mytalk.client.presenter.user.logicUser.loadViewLogUser()}.
						
						\item \texttt{testGetDataUser()}: viene verificata l'effettiva invocazione del metodo \path{mytalk.client.presenter.client.user.serverComUser.getUserData()}.
					\end{itemize}

					\item[] \textbf{Stato:} Superato
					\item[] \textbf{Bug individuati :} 1 \\
					\\ Errore di battitura nel messaggio di errore ritornato all’utente nel metodo \texttt{checkStringData()}. Tale errore è stato corretto.
				\end{itemize}
			\end{itemize}
			% DataUserLogic - fine
\newpage
			% LogUserLogic - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.presenter.user.logicUser.LogUserLogic}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:}\\ \path{mytalk.client.presenter.user.logicUser.LogUserLogicTest}

					\item[] \textbf{Descrizione:} \\Viene controllato che la classe:
					\begin{itemize}
						\item effettui un controllo corretto dei dati di login inseriti dall’utente;
						\item restituisca i corretti messaggi di errore;
						\item comunichi correttamente con le classi \path{mytalk.client.presenter.user.serverComUser.WebSocketUser} e \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic}.
					\end{itemize}
					
					\item[] \textbf{Metodi di test:}{
					\begin{itemize}
						\item \texttt{testValidateData()}: viene richiamato il metodo \texttt{validateData()} della classe \texttt{LogUserLogic} per tre volte: la prima con dei dati in input corretti, la seconda con la password sbagliata e la terza con l'indirizzo e-mail sbagliato. I dati in input sono contenuti in un \texttt{Vector} composto da due valori: nome utente (un indirizzo e-mail) e password (di almeno 8 caratteri per essere corretta). Viene verificato che il campo dati booleano \texttt{loginOk} della classe \texttt{LogUserLogic} contenga il valore appropriato e che venga richiamato il metodo \path{mytalk.client.presenter.user.serverComUser.authenticateUser(Vector<String>} \texttt{loginInput)} nel caso in cui i dati di login siano corretti, mentre nel caso di dati di login errati si verifica che venga richiamato il metodo \path{mytalk.client.presenter.user.logicUser.updateViewLogUser(boolean} \texttt{update, String message)}.
					\end{itemize}
					}

					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0\\

				\end{itemize}
			\end{itemize}
			% LogUserLogic - fine
			
			% UpdateViewLogic - inizio
			\begin{itemize}
			\item[•]\textbf{Classe \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:}\\
					\path{mytalk.client.presenter.user.logicUser.UpadateViewLogicTest}

					\item[] \textbf{Descrizione:}\\
					Si controlla che vengano richiamati correttamente i metodi della classe \texttt{PageUserView}.
					
					\item[] \textbf{Metodi di test:}{
					\begin{itemize}
						\item \texttt{testLoginResult()}: viene richiamato il metodo \texttt{loginResult boolean loginSuccess, Vector<String> loginInput}, prima con \texttt{loginSuccess} a \texttt{true} e poi a \texttt{false}, e si controlla che venga invocato correttamente il metodo \texttt{updateViewLogUser}. Nel caso della chiamata con \texttt{loginSuccess} a \texttt{true}, si controlla anche che venga creato il cookie\g~ di sessione.
						
						\item \texttt{testCheckLoggedUser()}: viene creato un cookie\g~ di sessione tramite il metodo \texttt{setCookie} della classe di GWT \texttt{Cookies} per simulare una sessione attiva, successivamente viene richiamato il metodo da testare \texttt{checkLoggedUser()} e si controlla che richiami il metodo \texttt{updateViewLogUser(boolean update, String message)} con i parametri corretti. Il cookie\g~ viene poi rimosso e viene richiamato nuovamente il metodo da testare, che in caso di cookie\g~ non esistente deve invece richiamare il metodo \texttt{loadViewLogUser()}.
						
						\item \texttt{testRegisterResult()}: viene richiamato due volte il metodo da testare \texttt{registerResult(boolean registerSuccess)}, la prima volta con argomento \texttt{true} e la seconda con argomento \texttt{false}. Nel caso di \texttt{registerSuccess == true}, deve essere richiamato il metodo \texttt{updateViewRegister(boolean registerSuccess, Vector<String> messages)} con l'argomento \texttt{messages} uguale ad un vettore vuoto, mentre nel caso di \texttt{registerSuccess == false} il metodo citato deve essere richiamato con l'argomento \texttt{messages} contenente, in posizione 0, il messaggio di errore ``username già attivo''.

						\item \texttt{testSetUsernameLabel()}: si verifica che il metodo da testare richiami il metodo \path{mytalk.client.view.user.setUsernameLabel(String} \texttt{username)} con la stringa corretta, ricavata dal cookie\g~ di sessione appositamente creato per il test.
						
						\item \texttt{testResultDataUser()}: viene richiamato due volte il metodo da testare \texttt{resultDataUser(boolean update)}, la prima volta con argomento \texttt{true} e la seconda con argomento \texttt{false}. Nel caso di \texttt{update == true}, deve essere richiamato il metodo \texttt{updateViewDataUser(boolean update, Vector<String> messages)} con l'argomento \texttt{messages} uguale ad un vettore vuoto, mentre nel caso di \texttt{update == false} il metodo citato deve essere richiamato con l'argomento \texttt{messages} contenente, in posizione 5, il messaggio di errore ``password errata''.
					\end{itemize}
					I metodi:
					\begin{itemize}
						\item \texttt{testUpdateViewLogUser()};
						\item \texttt{testNotifyCall()};
						\item \texttt{testNotifyRefuseCall()};
						\item \texttt{testSetUserList()};
						\item \texttt{testLoadViewRegister()};
						\item \texttt{testLoadViewLogUser()};
						\item \texttt{testUpdateViewReigister()};
						\item \texttt{testLoadViewUserData()};
						\item \texttt{testSetLocalVideo()};
						\item \texttt{testLoadViewCommunication()};
						\item \texttt{testUpdateViewDataUser()};
						\item \texttt{testSetUserDataLabel()};
						\item \texttt{testCallActive()};
					\end{itemize}
					Invocano il corrispondente metodo da testare nella classe \texttt{UpdateViewLogic} e verificano, attraverso l’oggetto di mock \texttt{mockPageUserView}, che venga richiamato il metodo corretto con i parametri corretti, ove questi siano richiesti.
					
				}
					\item[] \textbf{Stato:} Superato
					\item[] \textbf{Bug individuati:} 1\\
					Il metodo \texttt{checkLoggedUser()}: salva in una stringa il valore ritornato dal metodo \texttt{getCookieUsername()} della classe \texttt{ManageCookies}. Tale metodo, se il cookie\g~ è inesistente, ritorna \texttt{null}. Veniva assunto erroneamente che ritornasse stringa vuota, quindi veniva effettuato il controllo sul contenuto della stringa tramite il metodo \texttt{equals()}, che richiamato su un riferimento nullo provoca \texttt{NullPointerException}. Tale problema è stato risolto.
				\end{itemize}				
			\end{itemize}
			% UpdateViewLogic - fine
			
			% RegisterLogic - inizio
			\begin{itemize}
			\item[•]\textbf{Classe \path{mytalk.client.presenter.user.logicUser.RegisterLogic}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:}\\
					\path{mytalk.client.presenter.user.logicUser.RegisterLogicTest}

					\item[] \textbf{Descrizione:}\\
					Viene controllato che la classe:
					\begin{itemize}
						\item effettui un controllo corretto dei dati di registrazione inseriti dall’utente;
						\item restituisca i corretti messaggi di errore;
						\item comunichi correttamente con le classi \texttt{WebSocketUser} e \texttt{UpdateViewLogic};
					\end{itemize}									

					\item[] \textbf{Metodi di test:}{
					\begin{itemize}
						\item \texttt{testValidateData()}: viene richiamato il metodo \texttt{validateData()} della classe \texttt{RegisterLogic} per due volte, la prima con dei dati in input corretti e la seconda con dei dati non corretti. I dati in input sono contenuti in un \texttt{Vector} composto da due valori: nome utente (un indirizzo e-mail) e password (di almeno 8 caratteri per essere corretta). Viene verificato che il campo dati booleano \texttt{loginOk} della classe \texttt{RegisterLogic} contenga il valore appropriato.
					\end{itemize}
					}

					\item[] \textbf{Stato:} Superato 

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}			
			\end{itemize}
			}
			% RegisterLogic - fine
			
			% CommunicationLogic - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.presenter.user.logicUser.CommunicationLogic}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:\\mytalk.client.presenter.user.logicUser.CommunicationLogicTest}
					
					\item[] \textbf{Descrizione:} si verifica che vengano chiamati correttamente gli opportuni metodi, con i valori desiderati, delle classi \path{mytalk.client.presenter.user.communication.PeerConnection}, \path{mytalk.client.presenter.user.communication.MediaStream}, \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic} e \texttt{mytalk.client.presenter.user.serverComUser.WebSocketUser} quando viene invocato un metodo della classe \path{mytalk.client.presenter.user.logicUser.CommunicationLogic}.
					
					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testReceivedSession()}: viene creato un \texttt{Vector<String>} contenente un certo numero di elementi e si verifica che il metodo da testare richiami, per ogni elemento del vettore, il metodo \path{mytalk.client.presenter.user.communication.PeerConnection.addCandidate(String} \texttt{candidate)}. Vengono inoltre impostati, tramite mock, i metodi \texttt{getCandidates()} e \texttt{getRemoteURL()} della classe \texttt{PeerConnection} per ritornare delle stringhe arbitrarie; queste stringhe devono essere passate, oltre al nome del mittente, rispettivamente ai metodi \path{mytalk.client.presenter.user.serverComUser.WebSocketUser.sendAnswer(String} \texttt{mittente, String iceCandidate)} e \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.callActive(String} \texttt{remoteVideo, String nome)}.
						
						\item \texttt{testReceivedSessionPerformed()}: viene verificata la corretta invocazione dei metodi \path{mytalk.client.presenter.user.communication.IPeerConnection.receivedCommunication(Vector<String>} \texttt{candidate)} e \path{mytalk.client.presenter.user.communication.IPeerConnection.startStat()}.
						
						\item \texttt{testLogoutUser()}: viene creato un cookie\g~ di sessione tramite il metodo GWT \path{Cookies.setCookie(String} \texttt{name, String content)}, viene richiamato il metodo da testare e si controlla la corretta invocazione dei metodi della classe \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic} \texttt{removeCookies()} e \texttt{loadViewLogUser()}.
						
						\item \texttt{testGetLocalURL()}: attraverso il mock \texttt{mockMediaStream} si imposta il comportamento del metodo \path{mytalk.client.presenter.user.communication.MediaStream.localURL()} per fargli ritornare una certa stringa; si verifica poi che venga invocato il metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.setLocalVideo(String} \texttt{url)} con quella stringa.
						
						\item \texttt{testGetLocalURLnull()}: come il precedente, ma viene fatto ritornare il valore \texttt{null} al metodo \path{mytalk.client.presenter.user.communication.MediaStream.localURL()}. Si testa che non venga richiamato il metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.setLocalVideo(String} \texttt{url)}.
						
						\item \texttt{testCall()}: attraverso il mock \texttt{mockPeerConnection} viene fatta ritornare una particolare stringa al metodo \path{mytalk.client.presenter.user.communication.PeerConnection.getOffer()}. Si verifica che quella stringa venga passata correttamente al metodo \path{mytalk.client.presenter.serverComUser.WebSocketUser} \texttt{call(String utente, String offer)} e si controlla la corretta invocazione dei metodi \texttt{initialize()} e \texttt{addStream(MediaStream stream)} della classe \texttt{PeerConnection}.
						
						\item \texttt{testSetUserList()}: si controlla la corretta invocazione del metodo \path{mytalk.client.presenter.serverComUser.WebSocketUser.setUserList()}.
						
						\item \texttt{testAccept()}: attraverso il mock \texttt{mockPeerConnection} viene fatta ritornare una particolare stringa al metodo \path{mytalk.client.presenter.user.communication.PeerConnection.getAnswer()}. Si verifica che quella stringa venga passata correttamente al metodo \path{mytalk.client.presenter.serverComUser.WebSocketUser} \texttt{accept(String utente, String answer)}.
						
						\item \texttt{testRefuse()}: si controlla la corretta invocazione del metodo \path{mytalk.client.presenter.serverComUser.WebSocketUser.refuse(String} \texttt{utente)}.
						
						\item \texttt{testSearch()}: viene invocato il metodo di test prima con la stringa \texttt{``Ip''} e poi con la stringa \texttt{``EMail''} e si verifica la corretta invocazione dei metodi \texttt{SearchUserByIP(String ip)} e \texttt{SearchUserByEmail(String user} della classe \texttt{mytalk.client.presenter.user.serverComUser.WebSocketUser}.
						
						\item \texttt{testCallEnter()}: si verifica la corretta invocazione del metodo \path{mytalk.client.presenter.user.communication.PeerConnection.answer(String} \texttt{descrizione, IMediaStream stream)}.
						
						\item \texttt{testGetStats()}: viene creato un \texttt{Vector<Double>} al quale vengono aggiunti tre valori. Attraverso il mock \texttt{mockPeerConnection}, si impostano i metodi \texttt{getBytesSent()}, \texttt{getPacketsSent()} e \texttt{getPacketsLost()} della classe \path{mytalk.client.presenter.user.communication.PeerConnection} per ritornare gli stessi valori contenuti nel \texttt{Vector} creato. Si verifica quindi che venga richiamato il metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.updateFormInfoChiamata(Vector<String>} \texttt{stats)} con i valori desiderati.
						
						\item \texttt{testClose()}: viene creato un \texttt{Vector<Double>} al quale vengono aggiunti cinque valori. Attraverso il mock \texttt{mockPeerConnection}, si impostano i metodi \texttt{getPacketsSent()}, \texttt{getPacketsLost()}, \texttt{getBytesSent()}, \texttt{getInizio()} e \texttt{getFine()} della classe \path{mytalk.client.presenter.user.communication.PeerConnection} per ritornare gli stessi valori contenuti nel \texttt{Vector} creato. Si verifica quindi che venga richiamato il metodo \path{mytalk.client.presenter.serverComUser.WebSocketUser.sendStats(String} \texttt{ricevente, Vector<Double> statistiche)} con i valori desiderati.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}
			\end{itemize}
			% CommunicatinLogic - fine
	
\subsubsection{Package mytalk.client.presenter.user.logicUser.common}{
			% CommonFunctions - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.presenter.client.user.logicUser.common.CommonFunctions}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:}	\\ \path{mytalk.client.presenter.client.user.logicUser.common.CommonFunctionsTest}

					\item[] \textbf{Descrizione:} {\\Vengono controllate le varie stringhe passategli dalle classi.}
						Prima di iniziare il test, vengono create opportune stringhe contenenti dati corretti e dati sbagliati.
					
					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testCheckEmail()}: viene richiamato più volte il metodo da testare \texttt{testCheckEmail(String input)} con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
						
						\item \texttt{ttestCheckPassword()}: viene richiamato più volte il metodo da testare \texttt{testCheckEmail(String input)} con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
						
						\item \texttt{testCheckNameSurname()}: viene richiamato più volte il metodo da testare \texttt{testCheckNameSurname(String input)} con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
						
						\item \texttt{testCheckPasswordControl()}: viene richiamato più volte il metodo da testare \texttt{testCheckPasswordControl(String input)} con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
						
						\item \texttt{testCheckCompany()}: viene richiamato più volte il metodo da testare \texttt{testCheckCompany(String input)} con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
						
						\item \texttt{testCheckNumber()}: viene richiamato più volte il metodo da testare \texttt{testCheckNumber)(String input)}  con diverse combinazioni, corrette ed errate, di dati nella stringa passato in input, in modo da raggiungere una copertura totale dei controlli che il metodo effettua.
					\end{itemize}

					\item[] \textbf{Stato:} Superato
					\item[] \textbf{Bug individuati :} 0
					
				\end{itemize}
			\end{itemize}
			% CommonFunctions - fine
			}
			
		\subsubsection{Package mytalk.client.presenter.user.serverComUser} {

			% WebSocketUser - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.client.presenter.user.serverComUser.WebSocketUser}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:\\mytalk.client.presenter.user.serverComUser.WebSocketUserTest}
					
					\item[] \textbf{Descrizione:} viene verificate la corretta interpretazione dei messaggi provenienti dal server. Si creano diversi tipi di messaggi XML\g~ in modo da percorrere tutti i possibili cammini all'interno dei metodi deputati alla loro interpretazione.

					\item[] \textbf{Metodi di test:}

					\begin{itemize}
						\item \texttt{testCallEnter()}: si verifica la corretta invocazione del metodo \path{mytalk.client.presenter.user.communication.PeerConnection.answer(String} \texttt{descrizione, IMediaStream stream)}.
						
						\item \texttt{testParseXML\_c\_callNegotiation\_offer()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callNegotiation} e tipo uguale a \texttt{offer}. Poiché non c'è invocazione di altri metodi, viene verificata tramite EclEmma la corretta copertura del parser.
						
						\item \texttt{testParseXML\_c\_callNegotiation\_answer\_offline}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callNegotiation}, tipo uguale a \texttt{answer} e tag relativo allo stato dell'utente (\texttt{<st>}) impostato a \texttt{offline}. Viene verificata la corretta invocazione del metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.updatePanelSearch(boolean} \texttt{b, String utente)} con argomenti \texttt{false} e stringa vuota.
						
						\item \texttt{testParseXML\_c\_callNegotiation\_answer\_accepted()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callNegotiation}, tipo uguale a \texttt{answer} e tag relativo allo stato dell'utente impostato a \texttt{accepted}. Vengono inoltre impostati il tag utente (\texttt{<us>}) e il tag remote description (\texttt{<rd>}). Si verifica che venga invocato correttamente il metodo \texttt{mytalk.client.presenter.user.logicUser.acceptedCall(String} \texttt{answer, String utente} con i valori contenuti nel tag remote description e utente.
						
						\item \texttt{testParseXML\_c\_callNegotiation\_answer\_refused()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callNegotiation}, tipo uguale a \texttt{answer} e tag relativo allo stato dell'utente impostato a \texttt{refused}. Vengono inoltre impostati il tag utente (\texttt{<us>}) e il tag relativo allo stato (\texttt{<st>}), che contiene \texttt{refused}. Viene verificata la corretta invocazione del metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.notifyRefuseCall(String} \texttt{s} con argomento uguale al nome dell'utente impostato.
						
						\item \texttt{testParseXML\_c\_userList()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{userList} e tag relativi agli utenti (\texttt{<m>}) con dei nomi utente. Viene creato localmente un \texttt{Vector} contenente i nomi utente inseriti nei tag, e si controlla che venga passato un vettore uguale al metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.setUserList(Vector<String>} \texttt{listaUtenti)}.
						
						\item \texttt{testParseXML\_c\_callExchange\_answerDescription()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callExchange} e tipo uguale ad \texttt{answerDescription}. I tag relativi agli utenti (\texttt{<m>}) e agli ice candidates (\texttt{<ic>}) vengono popolati. Viene creato localmente un \texttt{Vector} contenente gli ice candidates inseriti nei tag, e si controlla che venga passato un vettore uguale al metodo \path{mytalk.client.presenter.user.logicUser.CommunicatinLogic.receivedSessionPerformed(Vector<String>} \texttt{candidate)}.
						
						\item \texttt{testParseXML\_c\_callExchange\_offerDescription()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{callExchange} e tipo uguale ad \texttt{offerDescription}. I tag relativi all'utente corrente (\texttt{<us>}), agli utenti (\texttt{<m>}) e agli ice candidates (\texttt{<ic>}) vengono popolati. Viene creato localmente un \texttt{Vector} contenente gli ice candidates inseriti nei tag, e si controlla che al metodo \path{mytalk.client.presenter.user.logicUser.CommunicatinLogic.receivedSession(String} \texttt{mittente, Vector<String> candidate)} vengano passati il nome utente contenuto nel tag \texttt{<us>} e un vettore uguale a quello creato.
						
						\item \texttt{testParseXML\_c\_find\_es\_true()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{find}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e all'esito (\texttt{<es>}). Si controlla che il metodo \path{mytalk.client.presenter.user.logicUser.CommunicatinLogic.call(final} \texttt{String user)} venga richiamato con argomento uguale al contenuto del tag \texttt{<m>} e che il metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.updatePanelSearch(boolean} \texttt{b, String utente)} venga invocato con argomenti uguali a \texttt{true} e al contenuto del tag \texttt{<m>}.
						
						\item \texttt{testParseXML\_c\_find\_es\_false()}: viene testato il parsing della stringa XML\g~ relativa alla comunicazione (\texttt{<c>}), con l'operazione uguale a \texttt{find}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.updatePanelSearch(boolean} \texttt{b, String utente)} venga invocato con argomenti uguali a \texttt{false} alla stringa vuota.
						
						\item \texttt{testParseXML\_ud\_log\_es\_true()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{log}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.loginResult(boolean} \texttt{loginSuccess, Vector<String> userInput)} venga invocato con argomento uguale a \texttt{true}.
						
						\item \texttt{testParseXML\_ud\_log\_es\_false()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{log}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.loginResult(boolean} \texttt{loginSuccess, Vector<String> userInput)} venga invocato con argomento uguale a \texttt{false}.
						
						\item \texttt{testParseXML\_ud\_add\_es\_true()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale ad \texttt{add}. Viene popolato il tag relativo all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.registerResult(boolean} \texttt{registerSuccess)} venga invocato con argomento uguale a \texttt{true}.
						
						\item \texttt{testParseXML\_ud\_add\_es\_false()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale ad \texttt{add}. Viene popolato il tag relativo all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.registerResult(boolean} \texttt{registerSuccess)} venga invocato con argomento uguale a \texttt{false}.
						
						\item \texttt{testParseXML\_ud\_mod\_es\_true()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{mod}. Viene popolato il tag relativo all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.resultDataUser(boolean} \texttt{update)} venga invocato con argomento uguale a \texttt{true}. Inoltre, nel metodo \texttt{setUp()} della classe di test, viene creato un cookie\g~ che la classe \texttt{WebSocketUser} utilizza per recuperare il valore da inserire nel nuovo cookie\g~. Si verifica che il nuovo cookie\g~ venga effettivamente creato con questo valore. 
						
						\item \texttt{testParseXML\_ud\_mod\_es\_false()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{mod}. Viene popolato il tag relativo all'esito (\texttt{<es>}). Si controlla che il metodo  \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.resultDataUser(boolean} \texttt{update)} venga invocato con argomento uguale a \texttt{false}.
						
						\item \texttt{testParseXML\_ud\_udt()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{udt}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e quelli relativi agli errori (\texttt{<er>}), oltre ai tag deputati alla raccolta dei dati utente: nome (\texttt{<nm>}), cognome (\texttt{<sn>}), società (\texttt{<sc>}), telefono (\texttt{<tl>}) e password (\texttt{<p>}). Si crea un \texttt{Vector} contenente i valori presenti nei campi dei dati utente e si verifica che ne venga passato uno uguale al metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.setUserDataLabel(Vector<String>} \texttt{userData)}.
						
						\item \texttt{testParseXML\_ud\_udt\_null()}: viene testato il parsing della stringa XML\g~ relativa ai dati utente (\texttt{<ud>}), con l'operazione uguale a \texttt{udt}. Vengono popolati i tag relativi agli utenti (\texttt{<m>}) e quelli relativi agli errori (\texttt{<er>}), oltre ai soli tag obbligatori tra quelli deputati alla raccolta dei dati utente: nome (\texttt{<nm>}), cognome (\texttt{<sn>}) e password (\texttt{<p>}). Si crea un \texttt{Vector} contenente i valori presenti nei campi dei dati utente e si verifica che ne venga passato uno uguale al metodo \path{mytalk.client.presenter.user.logicUser.UpdateViewLogic.setUserDataLabel(Vector<String>} \texttt{userData)}.
						
						\item \texttt{testParseXML\_ip()}: viene testato il parsing della stringa XML\g~ relativa all'indirizzo IP\g~ (\texttt{<ip>}). Viene popolato il tag relativo all'utente (\texttt{<us>}), nel quale viene inserito un indirizzo IP\g~. Si controlla la corretta creazione del cookie\g~ di sessione relativo all'indirizzo IP\g~, che deve contenere l'indirizzo presente nel tag (\texttt{<us>}), tramite il metodo della classe GWT \path{Cookies.getCookie(String} \texttt{cookieName)}.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}
			\end{itemize}
			% WebSocketUser - fine
			
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% TEST AMMINISTRATORE %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\newpage	
			% WebSocketAdmin - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalkadmin.client.presenter.serverComUser.WebSocketAdmin}}
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:\\mytalkadmin.client.presenter.serverComUser.WebSocketAdminTest}
					
					\item[] \textbf{Descrizione:} viene verificata la corretta interpretazione dei messaggi provenienti dal server. Si creano diversi tipi di messaggi XML\g~ in modo da percorrere tutti i possibili cammini all'interno dei metodi deputati alla loro interpretazione.

					\item[] \textbf{Metodi di test:}

					\begin{itemize}
						\item \texttt{testParseXML\_c\_userList()}: viene testato il parsing della stringa XML\g~ relativa alla richiesta della lista utenti. Vengono inseriti alcuni utenti nella stringa da passare al metodo da testare e si verifica che tale metodo invochi \path{mytalkadmin.client.presenter.logicAdmin.UpdateViewLogic.setUserList(Vector<String>} \texttt{listaUtenti)}
						
						\item \texttt{testParseXML\_c()}: viene testato il parsing della stringa XML\g~ relativa alla ricerca che può effettuare l'amministratore. Vengono inserite nella stringa due liste di ricerca, che vengono copiate in un \texttt{Vector<Vector<String>>} (ogni lista è un vettore, che viene inserito in un altro vettore). Si controlla che il metodo da testare recuperi correttamente i contenuti dei tag e che li inserisca nel \texttt{Vector}; tale vettore deve essere passato al metodo \path{mytalkadmin.client.presenter.logicAdmin.UpdateViewLogic.setListData(Vector<Vector<String>>} \texttt{list)}.
						
						\item \texttt{testParseXML\_c\_null()}: viene testato il parsing della stringa XML\g~ che contiene solamente il tag \texttt{<c>}. Si verifica che al metodo \path{mytalkadmin.client.presenter.logicAdmin.UpdateViewLogic.setListData(Vector<Vector<String>>} \texttt{list)} venga passato un \texttt{Vector<Vector<String>>} vuoto.
						
						\item \texttt{testParseXML\_ud\_log\_es\_true()}: viene testato il parsing della stringa XML\g~ relativa all'autenticazione dell'amministratore con esito positivo. Si verifica che il metodo \path{mytalkadmin.client.presenter.logicAdmin.UpdateViewLogic.loginResult(boolean} \texttt{loginSuccess, Vector<String> loginInput} venga invocato con argomento uguale a \texttt{true}.
						
						\item \texttt{testParseXML\_ud\_log\_es\_false()}: viene testato il parsing della stringa XML\g~ relativa all'autenticazione dell'amministratore con esito negativo. Si verifica che il metodo \path{mytalkadmin.client.presenter.logicAdmin.UpdateViewLogic.loginResult(boolean} \texttt{loginSuccess, Vector<String> loginInput} venga invocato con argomento uguale a \texttt{false}.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}
			\end{itemize}
			% WebSocketAdmin - fine
		}
		
		
	}
%	\end{sloppypar}
\newpage
\subsubsection{Package mytalk.server.presenter} {
		% XMLField - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.presenter.XMLField}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.presenter.XMLFieldTest}

					\item[] \textbf{Descrizione:} viene verificata la correttezza dell'oggetto per la raccolta dei metodi e dei riferimenti alle stringhe XML elaborate. 

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testLoadXMLFromString()}: si verifica la corretta creazione dell'oggetto per il riferimento dei nodi della stringa XML passata. Viene richiamato il metodo \texttt{loadXMLFromString(String xml)} della classe \texttt{XMLField}. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testExtractLogInfo()}: si verifica la corretta estrazione delle informazioni che servono per gestire l'accesso al servizio. Viene richiamato il metodo \texttt{extractLogInfo(Element e)} della classe \texttt{XMLField} per due volte. In entrambi i casi inizialmente viene chiamato il metodo \texttt{loadXMLFromString(String xml)} passandogli un particolare parametro \texttt{xml} e sull'oggetto \texttt{Document} ottenuto viene ricavato l'oggetto \texttt{e} che rappresenta l'elemento XML da passare come parametro al metodo \texttt{extractLogInfo(Element e)}. La prima volta \texttt{xml} contiene tutti gli elementi corretti ma non l'indirizzo IP, la seconda volta invece lo contiene. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testExtractRegInfo()}: si verifica la corretta estrazione delle informazioni che servono per gestire la registrazione al servizio. Viene richiamato il metodo \texttt{extractRegInfo(Element e)} della classe \texttt{XMLField} per tre volte. In tutti i casi inizialmente viene chiamato il metodo \texttt{loadXMLFromString(String xml)} passandogli un particolare parametro \texttt{xml} e sull'oggetto \texttt{Document} ottenuto viene ricavato l'oggetto \texttt{e} che rappresenta l'elemento XML da passare come parametro al metodo \texttt{extractRegInfo(Element e)}. La prima volta \texttt{xml} contiene tutti gli elementi corretti riguardanti la registrazione di un nuovo utente, la seconda volta ne contiene solo alcuni e la terza nessuno. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testExtractCommInfo()}: si verifica la corretta estrazione delle informazioni che servono per gestire la comunicazione attraverso il servizio. Viene richiamato il metodo \texttt{extractCommInfo(Element e)} della classe \texttt{XMLField}. Inizialmente viene chiamato il metodo \texttt{loadXMLFromString(String xml)} passandogli un particolare parametro \texttt{xml} e sull'oggetto \texttt{Document} ottenuto viene ricavato l'oggetto \texttt{e} che rappresenta l'elemento XML da passare come parametro al metodo \texttt{extractCommInfo(Element e)}. L'oggetto \texttt{xml} contiene tutti gli elementi corretti riguardanti una comunicazione. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testExtractFindInfo()}: si verifica la corretta estrazione delle informazioni che servono per gestire la comunicazione attraverso il servizio. Viene richiamato il metodo \texttt{extractFindInfo(Element e)} della classe \texttt{XMLField} per due volte. In entrambi i casi inizialmente viene chiamato il metodo \texttt{loadXMLFromString(String xml)} passandogli un particolare parametro \texttt{xml} e sull'oggetto \texttt{Document} ottenuto viene ricavato l'oggetto \texttt{e} che rappresenta l'elemento XML da passare come parametro al metodo \texttt{extractFindInfo(Element e)}. La prima volta \texttt{xml} contiene l'elemento corretto relativo all'indirizzo IP, la seconda volta invece non lo contiene. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testExtractStatReq()}: si verifica la corretta estrazione delle informazioni di riferimento per l'estrazione delle statistiche. Viene richiamato il metodo \texttt{extractStatReq(Element e)} della classe \texttt{XMLField} per quattro volte. In tutti i casi inizialmente viene chiamato il metodo \texttt{loadXMLFromString(String xml)} passandogli un particolare parametro \texttt{xml} e sull'oggetto \texttt{Document} ottenuto viene ricavato l'oggetto \texttt{e} che rappresenta l'elemento XML da passare come parametro al metodo \texttt{extractStatReq(Element e)}. La prima volta \texttt{xml} contiene l'attributo \texttt{time} e l'elemento \texttt{email} corretti, la seconda volta contiene l'attributo \texttt{time} e l'elemento \texttt{grade} corretti, la terza volta contiene l'attributo \texttt{time} e l'elemento \texttt{dateStart} corretti e la quarta non contiene nessun elemento e nessun attributo. Viene verificato che il metodo ritorni l'oggetto corretto.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% XMLField - fine

		}
		
		\subsubsection{Package mytalk.server.presenter.administrator.logicAdmin} {
		% ManageWSA - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.presenter.administrator.logicAdmin.ManageWSA}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.presenter.administrator.logicAdmin.ManageWSATest}

					\item[] \textbf{Descrizione:} viene verificata la correttezza dell'oggetto per la gestione delle richieste in formato XML relative all'amministratore da inoltrare al Model.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testGetOperation()}: si verifica il corretto recupero dell'informazione riguardante l'identificativo dell'ultima operazione effettuata. Viene richiamato il metodo \texttt{getOperation()} della classe \texttt{ManageWSA}. Inizialmente si invoca il metodo \texttt{testRequest(String xml)} passandogli un particolare parametro \texttt{xml} che contiene il tipo di operazione da effettuare. Poi sullo stesso oggetto si invoca il metodo \texttt{getOperation()}. Viene verificato che il metodo ritorni l'identificativo corretto dell'operazione.
						\end{itemize}
						
Nei prossimi test si verifica, a seconda del tipo di operazione rilevato, la corretta chiamata del metodo privato che gestisce l'operazione individuata. In ogni test viene invocato il metodo \texttt{request(String xml)} della classe \texttt{ManageWSA} passandogli, ogni volta, un diverso parametro \texttt{xml}. Per ogni test viene verificato che il metodo ritorni il messaggio corretto.
					\begin{itemize}
						\item \texttt{testRequestEmpty()}: l'oggetto \texttt{xml} non contiene nessun elemento di tipo comunicazione o amministratore.
						
						\item \texttt{testRequestOpLog()}: si verifica la corretta chiamata del metodo privato che verifica i dati di login dell'amministratore. Il metodo \texttt{request(String xml)} viene invocato tre volte. In tutti i casi \texttt{xml} contiene un elemento di tipo amministratore. La prima volta contiene un elemento corretto di tipo amministratore, la seconda contiene un elemento di tipo amministratore ma con indirizzo email non presente nel database e la terza contiene un elemento di tipo amministratore ma con password errata.
						
						\item \texttt{testRequestOpGetStat()}: si verifica la corretta chiamata del metodo privato che verifica i valori di riferimento per l'estrazione delle statistiche. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo comunicazione. La prima volta contiene un elemento corretto di tipo comunicazione e la seconda contiene un elemento di tipo comunicazione ma con la data troppo vecchia per poter essere visualizzata.
						
						\item \texttt{testRequestOpUserList()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta per l'ottenimento della lista utenti. L'oggetto \texttt{xml} contiene un elemento corretto di tipo comunicazione.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% ManageWSA - fine
			
			% WSAdmin - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.presenter.administrator.logicAdmin.WSAdmin}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.presenter.administrator.logicAdmin.WSAdminTest}

					\item[] \textbf{Descrizione:} si verifica la correttezza dell'oggetto servlet per la gestione delle connessioni WebSocket e dello scambio d'informazioni.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testCreateWebSocketInbound()}: si verifica la corretta creazione dell'istanza per l'elaborazione della connessione in ingresso. Viene invocato il metodo \texttt{createWebSocketInbound(String arg0, HttpServletRequest arg1)} della classe \texttt{WSAdmin}. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testOnOpen()}: si verifica la corretta gestione della richiesta di apertura di una connessione HTTP per la creazione di una WebSocket. Viene invocato il metodo \texttt{onOpen(WsOutbound outbound)} della classe \texttt{WSAdmin}. Viene verificato che il metodo gestisca correttamente la creazione della connessione.				
						
						\item \texttt{testOnTextMessageNull()}: si verifica la corretta ricezione di un messaggio testuale da parte del client. Viene invocato il metodo \texttt{onTextMessage(CharBuffer buffer)} della classe \texttt{WSAdmin} specificando il riferimento al client a cui spedire il messaggio. Viene verificato che il metodo crei il messaggio corretto.						
						
						\item \texttt{testOnTextMessage()}: si verifica la corretta ricezione di un messaggio testuale da parte del client. Viene invocato il metodo \texttt{onTextMessage(CharBuffer buffer)} della classe \texttt{WSAdmin} senza specificare il riferimento al client a cui spedire il messaggio. Viene verificato che il metodo crei il messaggio corretto.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% WSAdmin - fine
		}
		
		\subsubsection{Package mytalk.server.presenter.user.logicUser} {
		% ManageWSU - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.presenter.user.logicUser.ManageWSU}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.presenter.user.logicUser.ManageWSUTest}

					\item[] \textbf{Descrizione:} viene verificata la correttezza dell'oggetto per la gestione dei messaggi scambiati tra client e server.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testGetOperation()}: si verifica il corretto recupero dell'informazione riguardante l'identificativo dell'ultima operazione effettuata. Viene richiamato il metodo \texttt{getOperation()} della classe \texttt{ManageWSU}. Inizialmente si invoca il metodo \texttt{testRequest(String xml)} passandogli un particolare parametro \texttt{xml} che contiene il tipo di operazione da effettuare. Poi sullo stesso oggetto si invoca il metodo \texttt{getOperation()}. Viene verificato che il metodo ritorni l'identificativo corretto dell'operazione.
						
						\item \texttt{testGetRefUser()}: si verifica il corretto recupero dell'informazione riguardante l'indirizzo email dell'utente di riferimento. Viene richiamato il metodo \texttt{getRefUser()} della classe \texttt{ManageWSU}. Inizialmente si invoca il metodo \texttt{testRequest(String xml)} passandogli un particolare parametro \texttt{xml} che contiene l'indirizzo email dell'utente di riferimento. Poi sullo stesso oggetto si invoca il metodo \texttt{getRefUser()}. Viene verificato che il metodo ritorni l'indirizzo email corretto dell'utente di riferimento.
						
						\item \texttt{testGetDestUser()}: si verifica il corretto recupero dell'informazione riguardante l'indirizzo email dell'utente destinatario. Viene richiamato il metodo \texttt{getDestUser()} della classe \texttt{ManageWSU}. Inizialmente si invoca il metodo \texttt{testRequest(String xml)} passandogli un particolare parametro \texttt{xml} che contiene l'indirizzo email dell'utente destinatario. Poi sullo stesso oggetto si invoca il metodo \texttt{getDestUser()}. Viene verificato che il metodo ritorni l'indirizzo email corretto dell'utente destinatario.
						\end{itemize}

Nei prossimi test si verifica, a seconda del tipo di operazione rilevato, la corretta chiamata del metodo privato che gestisce l'operazione individuata. In ogni test viene invocato il metodo \texttt{request(String xml)} della classe \texttt{ManageWSU} passandogli, ogni volta, un diverso parametro \texttt{xml}. Per ogni test viene verificato che il metodo ritorni il messaggio corretto.
					\begin{itemize}
						\item \texttt{testRequestEmpty()}: l'oggetto \texttt{xml} non contiene nessun elemento di tipo comunicazione o utente.
						
						\item \texttt{testRequestOpLog()}: si verifica la corretta chiamata del metodo privato che verifica i dati di login dell'utente. Il metodo \texttt{request(String xml)} viene invocato tre volte. In tutti i casi \texttt{xml} contiene un elemento di tipo utente. La prima volta con l'elemento email sbagliato, la seconda con l'elemento password errato e la terza con l'elemento corretto.
						   
						\item \texttt{testRequestOpULog()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di logout dell'utente. L'oggetto \texttt{xml} contiene un elemento corretto di tipo utente.
						
						\item \texttt{testRequestOpAdd()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di aggiunta di un nuovo utente. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo utente. La prima volta contiene un utente già presente nel database, la seconda contiene un utente non presente.
						
						\item \texttt{testRequestOpMod()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di modifica dei dati utente. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo utente per la modifica dell'indirizzo email. La prima volta contiene un indirizzo email già presente nel database, la seconda contiene un indirizzo email non presente.
						
						\item \texttt{testRequestOpUdt()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di raccolta delle informazioni dell'utente. Il metodo \texttt{request(String xml)} viene invocato tre volte. In tutti i casi \texttt{xml} contiene un elemento di tipo utente. La prima volta non contiene il numero di telefono, la seconda contiene un elemento corretto e la terza non contiene il numero di telefono e la società.
						
						\item \texttt{testRequestOpDel()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di eliminazione dell'utente. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo utente. La prima volta contiene un utente presente nel database, la seconda contiene un utente non presente.
						
						\item \texttt{testRequestOpUserList()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta per l'ottenimento della lista utenti. L'oggetto \texttt{xml} contiene un elemento corretto di tipo comunicazione.
						
						\item \texttt{testRequestOpCNeg()}: si verifica la corretta chiamata del metodo privato che effettua la gestione per la negoziazione della comunicazione. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo comunicazione. La prima volta contiene l'utente destinatario offline, la seconda l'utente online.
						
						\item \texttt{testRequestOpCEx()}: si verifica la corretta chiamata del metodo privato che effettua la richiesta di inoltro dello scambio della comunicazione. L'oggetto \texttt{xml} contiene un elemento corretto di tipo comunicazione.
						
						\item \texttt{testRequestOpIStat()}: si verifica la corretta chiamata del metodo privato che effettua la registrazione delle statistiche relative alla comunicazione. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo comunicazione. La prima volta contiene un elemento sbagliato, la seconda un elemento corretto.
						
						\item \texttt{testRequestOpFu()}: si verifica la corretta chiamata del metodo privato che effettua la ricerca di un utente mediante campi dati indicati. Il metodo \texttt{request(String xml)} viene invocato due volte. In tutti i casi \texttt{xml} contiene un elemento di tipo comunicazione. La prima volta non contiene l'elemento IP, la seconda invece lo contiene.
						
						\item \texttt{testRequestOpAnswering()}: si verifica la corretta chiamata del metodo privato che gestisce la richiesta di archiviazione di un nuovo messaggio di segreteria. L'oggetto \texttt{xml} contiene un elemento corretto di tipo comunicazione.
					
						\item \texttt{testRequestOpAnsweringDel()}: si verifica la corretta chiamata del metodo privato che gestisce la richiesta di eliminazione di un messaggio presente in segreteria. L'oggetto \texttt{xml} contiene un elemento corretto di tipo comunicazione.
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% ManageWSU- fine
			
			% WSUser - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.presenter.user.logicUser.WSUser}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.presenter.user.logicUser.WSUserTest}

					\item[] \textbf{Descrizione:} si verifica la correttezza dell'oggetto servlet per la gestione delle comunicazioni server-client.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testCreateWebSocketInbound()}: si verifica la corretta creazione dell'istanza per l'elaborazione della connessione in ingresso. Viene invocato il metodo \texttt{createWebSocketInbound(String arg0, HttpServletRequest arg1)} della classe \texttt{WSUser}. Viene verificato che il metodo ritorni l'oggetto corretto.
						
						\item \texttt{testOnOpen()}: si verifica la corretta gestione della richiesta di creazione di una nuova connessione da parte di un client. Viene invocato il metodo \texttt{onOpen(WsOutbound outbound)} della classe \texttt{WSUser}. Viene verificato che il metodo gestisca correttamente la creazione della connessione.
						\end{itemize}
						
Nei prossimi test si verifica la corretta gestione dell'operazione da eseguire ad ogni richiesta del client. In ogni test viene invocato il metodo \texttt{onTextMessage(CharBuffer buffer)} della classe \texttt{WSUser}. Per ogni test viene verificato che il metodo gestisca correttamente l'operazione corrispondente.
					\begin{itemize}
						\item \texttt{testOnTextMessageNull()}: gli viene passato il parametro \texttt{buffer} nullo.					
					
						\item \texttt{testOnTextMessageOpLog()}: si verifica la corretta gestione dell'operazione di login dell'utente nel caso in cui l'utente abbia già effettuato il login.
						
						\item \texttt{testOnTextMessageOpLogNull()}: si verifica la corretta gestione \newline dell'operazione di login dell'utente nel caso in cui l'utente non abbia ancora effettuato il login.
						
						\item \texttt{testOnTextMessageOpULog()}:  si verifica la corretta gestione dell'operazione di logout dell'utente.
						
						\item \texttt{testOnTextMessageOpCNeg()}: si verifica la corretta gestione dell'operazione di negoziazione della comunicazione.
						
						\item \texttt{testOnTextMessageOpCEx()}: si verifica la corretta gestione dell'operazione di scambio delle informazioni della comunicazione.
						
						\item \texttt{testOnTextMessageOpAnsweringNull()}: si verifica la corretta gestione dell'operazione di archiviazione di un nuovo messaggio di segreteria nel caso in cui l'utente destinatario non sia presente nell'apposito registro.
						
						\item \texttt{testOnTextMessageOpAnswering()}: si verifica la corretta gestione dell'operazione di archiviazione di un nuovo messaggio di segreteria nel caso in cui l'utente destinatario sia già presente nell'apposito registro.	

						\item \texttt{testOnTextMessageOpAnsweringDelete()}: si verifica la corretta gestione dell'operazione di archiviazione di un nuovo messaggio di segreteria.

						\item \texttt{testOnTextMessage()}: si verifica la corretta gestione dell'invio dei messaggi presenti in segreteria agli utenti destinatari corretti.						
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% WSUser - fine
		}
		
		%fine presenter
	\end{sloppypar}
	}

\newpage	
\subsection{Model}{
	L'obiettivo di questi test è quello di verificare il corretto funzionamento della logica dei metodi delle classi che compongono il Model. Per l’esecuzione dei test sono stati utilizzati i seguenti framework$_{|g|}$ di testing:
	\begin{itemize}
		\item[•] JUnit 4: permette di scrivere ed eseguire in modo automatizzato i \underline{test case}$_{|g|}$.
	\end{itemize}
		
		L'obiettivo di questi test è quello di verificare il corretto funzionamento della logica dei metodi delle classi che compongono il Model. Per l’esecuzione dei test sono stati utilizzati i seguenti framework$_{|g|}$ di testing:
	\begin{itemize}
		\item[•] JUnit 4: permette di scrivere ed eseguire in modo automatizzato i \underline{test case}$_{|g|}$.
	\end{itemize}
		
		\subsubsection{Package mytalk.server.model.dao}{
			
			% DataAccessObject - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.model.dao.DataAccessObject}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.model.dao.DataAccessObjectTest}

					\item[] \textbf{Descrizione:} viene verificata la corretta gestione delle comunicazioni con il database.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testGetInfo()}: si verifica il corretto recupero delle informazioni dal database secondo specifici parametri di richiesta. Viene richiamato il metodo \texttt{getInfo(String[] fields, ObjectTransfer ui, String table)} della classe \texttt{DataAccessObject} per due volte. La prima passandogli in input valori contenuti nel database e la seconda passandogli valori non contenuti nel database. I valori in input sono contenuti in un \texttt{HashMap} composto da due valori: il nome e il cognome dell'utente. Viene verificato che il metodo ritorni il numero corretto di righe contenenti quei valori.
						
						\item \texttt{testGetUserInfoByField()}: si verifica il corretto recupero delle informazioni dell'utente dal database secondo un specifico campo scelto. Viene richiamato il metodo \texttt{getUserInfoByField(String k, String v)} della classe \texttt{DataAccessObject} per due volte. La prima passandogli in input valori contenuti nel database e la seconda passandogli valori non contenuti nel database. I valori in input indicano il campo in cui cercare e il nome dell'utente da cercare. Viene verificato che il metodo ritorni il numero corretto di righe contenenti quei valori.
						
						\item \texttt{testGetUserInfo()}: si verifica il corretto recupero delle informazioni dell'utente dal database secondo l'indirizzo email. Viene richiamato il metodo \texttt{getUserInfo(String v)} della classe \texttt{DataAccessObject} per tre volte. La prima passandogli in input un valore contenuto nel database, la seconda passandogli un valore non contenuto nel database e la terza passandogli un valore nullo. Il valore in input, nei primi due casi, contiene l'indirizzo email dell'utente da cercare. Viene verificato che il metodo ritorni il numero corretto di righe contenenti quei valori.
						
						\item \texttt{testGetAdminInfoByField()}: si verifica il corretto recupero delle informazioni dell'amministratore secondo un specifico campo scelto. \newline Viene richiamato il metodo \texttt{getAdminInfoByField(String k, String v)} della classe \texttt{DataAccessObject} per due volte. La prima passandogli in input valori contenuti nel database e la seconda passandogli valori non contenuti nel database. I valori in input indicano il campo in cui cercare e il nome dell'amministratore da cercare. Viene verificato che il metodo ritorni il numero corretto di righe contenenti quei valori.
						
						\item \texttt{testGetAdminInfo()}: si verifica il corretto recupero delle informazioni dell'amministratore secondo l'indirizzo email. Viene richiamato il metodo \texttt{getAdminInfo(String v)} della classe \texttt{DataAccessObject} per tre volte. La prima passandogli in input un valore contenuto nel database, la seconda passandogli un valore non contenuto nel database e la terza passandogli un valore nullo. Il valore in input, nei primi due casi, contiene l'indirizzo email dell'amministratore da cercare. Viene verificato che il metodo ritorni il numero corretto di righe contenenti quei valori.
						
						\item \texttt{testGetCommInfoByOT()}: si verifica il corretto recupero delle informazioni della comunicazione secondo specifici parametri indicati nell'oggetto passato in input. Viene richiamato il metodo \newline \texttt{getCommInfoByOT(ObjectTransfer fil, String time)} della classe \texttt{DataAccessObject} per tre volte. La prima passandogli in input \newline parametri non nulli, la seconda passandogli il parametro \texttt{time} nullo e la terza passandogli entrambi i parametri nulli. I parametri in input indicano, \texttt{fil}, l'oggetto \texttt{ObjectTransfer} contenente i valori da cercare e, \texttt{time}, il numero di secondi da togliere alla data e ora attuale. Viene verificato che il metodo ritorni il numero corretto di righe corrispondenti ai valori definiti nei parametri.
						
						\item \texttt{testGetCommInfoByField()}: si verifica il corretto recupero delle informazioni della comunicazione secondo un specifico campo scelto. Viene richiamato il metodo \newline \texttt{getCommInfoByField(String k, String v, String time)} della \newline classe \texttt{DataAccessObject} per due volte. La prima passandogli in input parametri non nulli e la seconda passandogli il parametro \texttt{time} nullo. I parametri in input indicano, \texttt{k} il campo in cui cercare, \texttt{v} l'indirizzo email dell'utente chiamante ed infine \texttt{time} il numero di secondi da togliere alla data e ora attuale. Viene verificato che il metodo ritorni il numero corretto di righe corrispondenti ai valori definiti nei parametri.
						
						\item \texttt{testGetCommInfo()}: si verifica il corretto recupero delle informazioni di tutte le comunicazioni presenti nel database. Viene richiamato il metodo \texttt{getCommInfo()} della classe \texttt{DataAccessObject}. Viene verificato che il metodo ritorni il numero corretto di righe.
						
						\item \texttt{testInsertItem()}: si verifica il corretto inserimento di nuovi dati nel database. Viene richiamato il metodo \texttt{insertItem(ObjectTransfer ins)} della classe \texttt{DataAccessObject} per quattro volte. Le prime tre volte passandogli in input un oggetto \texttt{ObjectTransfer}, rispettivamente di tipo utente, amministratore e comunicazione, contenente rispettivamente i dati di un utente, di un amministratore e di una comunicazione da inserire nel database. La quarta volta viene passato un parametro nullo. Viene verificato che il metodo ritorni il numero corretto di nuove righe inserite nel database.
						
						\item \texttt{testUpdateItem()}: si verifica il corretto aggiornamento di dati già presenti nel database secondo parametri di riferimento. Viene richiamato il metodo \texttt{updateItem(ObjectTransfer insRef, ObjectTransfer insMod)} della classe \texttt{DataAccessObject} per sei volte. La prime due passandogli rispettivamente il parametro \texttt{insRef} e il parametro \texttt{insMod} nulli. La terza passandogli i parametri di tipo diverso tra loro. Le ultime tre passandogli in input entrambi gli oggetti \texttt{ObjectTransfer}, rispettivamente di tipo utente, amministratore e comunicazione, cioè \texttt{insRef} contenente rispettivamente i dati dell'utente, dell'amministratore e della comunicazione da aggiornare, \texttt{insMod} contenente rispettivamente i nuovi dati dell'utente, dell'amministratore e della comunicazione. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateUserByField()}: si verifica il corretto aggiornamento dei dati dell'utente secondo un unico riferimento. Viene richiamato il metodo \texttt{updateUserByField(String k, String v, ObjectTransfer ot)} della classe \texttt{DataAccessObject} per cinque volte. Le prime tre con rispettivamente \texttt{k} nullo, \texttt{v} nullo e \texttt{ot} nullo. La quarta con tipo di ot diverso dall'utente. La quinta con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} il nome dell'utente da aggiornare ed \texttt{ot} i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateUserByEmail()}: si verifica il corretto aggiornamento dei dati dell'utente secondo l'indirizzo email. Viene richiamato il metodo \texttt{updateUserByEmail(String k, ObjectTransfer ot)} della classe \texttt{DataAccessObject} con i parametri corretti: con \texttt{k} contenente l'inidirzzo email dell'utente da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateUserByID()}: si verifica il corretto aggiornamento dei dati dell'utente secondo l'ID. Viene richiamato il metodo \newline \texttt{updateUserByID(String k, ObjectTransfer ot)} della classe \newline \texttt{DataAccessObject} con i parametri corretti, quindi con \texttt{k} contenente l'ID dell'utente da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateAdminByField()}: si verifica il corretto aggiornamento dei dati dell'amministratore secondo un unico riferimento. Viene richiamato il metodo \newline \texttt{updateAdminByField(String k, String v, ObjectTransfer ot)} \newline della classe \texttt{DataAccessObject} per cinque volte. Le prime tre con rispettivamente \texttt{k} nullo, \texttt{v} nullo e \texttt{ot} nullo. La quarta con tipo di ot diverso dall'amministratore. La quinta con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} il nome dell'amministratore da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateAdminByEmail()}: si verifica il corretto aggiornamento dei dati dell'amministratore secondo l'indirizzo email. Viene richiamato il metodo \texttt{updateAdminByEmail(String k, ObjectTransfer ot)} della classe \texttt{DataAccessObject} con i parametri corretti, quindi con \texttt{k} contenente l'inidirzzo email dell'amministratore da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateAdminByID()}: si verifica il corretto aggiornamento dei dati dell'amministratore secondo l'ID. Viene richiamato il metodo \newline \texttt{updateAdminByID(String k, ObjectTransfer ot)} della classe \newline \texttt{DataAccessObject} con i parametri corretti, quindi con \texttt{k} contenente l'ID dell'amministratore da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testUpdateCommByField()}: si verifica il corretto aggiornamento dei dati della comunicazione secondo un unico riferimento. Viene richiamato il metodo \newline \texttt{updateCommByField(String k, String v, ObjectTransfer ot)} \newline della classe \texttt{DataAccessObject} per cinque volte. Le prime tre con rispettivamente \texttt{k} nullo, \texttt{v} nullo e \texttt{ot} nullo. La quarta con tipo di ot diverso dalla comunicazione. La quinta con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} l'ID della comunicazione da aggiornare ed \texttt{ot} con i nuovi dati. Viene verificato che il metodo ritorni il numero corretto di righe aggiornate nel database.
						
						\item \texttt{testDeleteItem()}: si verifica la corretta cancellazione dei dati dal database. Viene richiamato il metodo \texttt{deleteItem(ObjectTransfer del)} della classe \texttt{DataAccessObject} per quattro volte. Le prime tre volte passandogli in input un oggetto \texttt{ObjectTransfer}, rispettivamente di tipo utente, amministratore e comunicazione, contenente rispettivamente i dati di un utente, di un amministratore e di una comunicazione da cancellare dal database. La quarta volta viene passato un parametro nullo. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteUserByField()}: si verifica la corretta cancellazione di un utente secondo un unico riferimento. Viene richiamato il metodo \newline \texttt{deleteUserByField(String k, String v)} della classe \newline \texttt{DataAccessObject} per tre volte. Le prime due con rispettivamente \texttt{k} nullo e \texttt{v} nullo. La terza con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} il nome dell'utente da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteUserByID()}: si verifica la corretta cancellazione di un utente secondo l'ID. Viene richiamato il metodo \texttt{deleteUserByID(String v)} della classe \texttt{DataAccessObject} per due volte. La prima con \texttt{v} nullo. La seconda con il parametro corretto, quindi con \texttt{v} contenente l'ID dell'utente da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteUserByEmail()}: si verifica la corretta cancellazione di un utente secondo l'indirizzo email. Viene richiamato il metodo \newline \texttt{deleteUserByEmail(String v)} della classe \texttt{DataAccessObject} per due volte. La prima con \texttt{v} nullo. La seconda con il parametro corretto, quindi con \texttt{v} contenente l'indirizzo email dell'utente da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteAdminByField()}: si verifica la corretta cancellazione di un amministratore secondo un unico riferimento. Viene richiamato il metodo \texttt{deleteAdminByField(String k, String v)} della classe \newline \texttt{DataAccessObject} per tre volte. Le prime due con rispettivamente \texttt{k} nullo e \texttt{v} nullo. La terza con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} il nome dell'amministratore da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteAdminByID()}: si verifica la corretta cancellazione di un amministratore secondo l'ID. Viene richiamato il metodo \newline \texttt{deleteAdminByID(String v)} della classe \texttt{DataAccessObject} per due volte. La prima con \texttt{v} nullo. La seconda con il parametro corretto, quindi con \texttt{v} contenente l'ID dell'amministratore da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteAdminByEmail()}: si verifica la corretta cancellazione di un amministratore secondo l'indirizzo email. Viene richiamato il metodo \texttt{deleteAdminByEmail(String v)} della classe \texttt{DataAccessObject} per due volte. La prima con \texttt{v} nullo. La seconda con il parametro corretto, quindi con \texttt{v} contenente l'indirizzo email dell'amministratore da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
						
						\item \texttt{testDeleteCommByField()}: si verifica la corretta cancellazione di una comunicazione secondo un unico riferimento. Viene richiamato il metodo \texttt{deleteCommByField(String k, String v)} della classe \newline \texttt{DataAccessObject} per tre volte. Le prime due con rispettivamente \texttt{k} nullo e \texttt{v} nullo. La terza con i parametri corretti, quindi con \texttt{k} contenente il campo in cui cercare, \texttt{v} il numero di byte trasmessi della comunicazione da cancellare. Viene verificato che il metodo ritorni il numero corretto di righe cancellate dal database.
					\end{itemize}
					
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% DataAccessObject - fine
			
			% ObjectTransfer - inizio
			\begin{itemize}
				\item[•]\textbf{Classe \path{mytalk.server.model.dao.ObjectTransfer}} 
				\begin{itemize}
					\item[] \textbf{Classe che realizza i test:} \\ \path{mytalk.server.model.dao.ObjectTransferTest}

					\item[] \textbf{Descrizione:} viene verificata la correttezza dell'oggetto di trasferimento per le informazioni della classe \texttt{DataAccessObject}.

					\item[] \textbf{Metodi di test:}
					\begin{itemize}
						\item \texttt{testGetTableInfo()}: si verifica il corretto recupero dell'informazione riguardante il tipo di tabella che si incorpora. Viene richiamato il metodo \texttt{getTableInfo()} della classe \texttt{ObjectTransfer} per tre volte. La prima su un oggetto di tipo utente, la seconda su un oggetto di tipo amministratore e la terza su un oggetto di tipo comunicazione. Viene verificato che il metodo ritorni il tipo corretto.
						
						\item \texttt{testAddMap()}: si verifica il corretto inserimento di una tabella nell'oggetto. Viene richiamato il metodo \newline \texttt{addMap(HashMap<String, String> e)} della classe \texttt{ObjectTransfer} per due volte. La prima con \texttt{e} nullo e la seconda con il parametro corretto, quindi con \texttt{e} contenente la tabella da aggiungere. Viene verificato che l'oggetto di invocazione contenga il numero corretto di tabelle.
						
						\item \texttt{testGetEmptyMapString()}: si verifica la corretta creazione di una nuova tabella vuota con i valori delle chiavi già configurati secondo il tipo indicato nel parametro . Viene richiamato il metodo \newline \texttt{getEmptyMap(String t)} della classe \texttt{ObjectTransfer} per tre volte. La prima con \texttt{t} == user, la seconda con \texttt{t} == admin e la terza con \texttt{t} == comm. Viene verificato che il metodo ritorni la tabella di tipo corretto.
						
						\item \texttt{testGetEmptyMap()}: si verifica la corretta creazione di una nuova tabella vuota con i valori delle chiavi già configurati secondo la tipologia dell'oggetto di invocazione. Viene richiamato il metodo \texttt{getEmptyMap()} della classe \texttt{ObjectTransfer} per tre volte. La prima su un oggetto di tipo utente, la seconda su un oggetto di tipo amministratore e la terza su un oggetto di tipo comunicazione. Viene verificato che il metodo ritorni la tabella di tipo corretto.
						
						\item \texttt{testGetSize()}: si verifica il corretto recupero dell'informazione \newline riguardante il numero di tabelle contenute nell'oggetto. Viene richiamato il metodo \texttt{getSize()} della classe \texttt{ObjectTransfer}. Viene verificato che l'oggetto di invocazione contenga il numero corretto di tabelle.
						
						\item \texttt{testGetMapInt()}: si verifica il corretto recupero della tabella contenuta nell'oggetto nella posizione indicata dal parametro. Viene richiamato il metodo \texttt{getMap(int i)} della classe \texttt{ObjectTransfer} per tre volte. La prima con \texttt{i} $<$ 0, la seconda con \texttt{i} maggiore della dimensione dell'oggetto di invocazione e la terza con \texttt{i} $\geq$ 0. Viene verificato che il metodo ritorni la tabella corretta.
						
						\item \texttt{testGetMap()}: si verifica il corretto recupero della prima tabella contenuta nell'oggetto. Viene richiamato il metodo \texttt{getMap()} della classe \texttt{ObjectTransfer}. Viene verificato che il metodo ritorni la tabella corretta.
						
						\item \texttt{testSetFieldMap()}: si verifica il corretto inserimento nella tabella in posizione indicata della coppia chiave-valore segnalata. Viene richiamato il metodo \texttt{setFieldMap(String k, String v, int m)} della classe \texttt{ObjectTransfer} per tre volte. La prima con tabella in posizione \newline \texttt{m} $<$ 0, la seconda con tabella in posizione \texttt{m} maggiore della dimensione dell'oggetto di invocazione e la terza con parametri corretti quindi con \texttt{k} contenente la chiave, \texttt{v} contenente il valore e \texttt{m} contenente la posizione della tabella da recuperare. Viene verificato che l'oggetto di invocazione contenga il numero corretto di tabelle e che la tabella indicata contenga il numero corretto di coppie chiave-valore.
	 
					\end{itemize}
					\item[] \textbf{Stato:} Superato

					\item[] \textbf{Bug individuati:} 0
				\end{itemize}	
			\end{itemize}
			% ObjectTransfer - fine

		}

\newpage
	\subsection{Tabella riassuntiva dei test di unità}{
		\begin{table}[h!]
			\scriptsize
			\begin{center}
				\begin{tabular}{c l c c}				
					\toprule
					Data 	   & Classe testata 											& Esito 	& Bug rivelati \\ 
					\midrule
					2013-05-10 & mytalk.client.model.localDataUser.ManageCookies 		 	 & Superato & 0 \\ 
					2013-05-10 & mytalk.client.presenter.user.logicUser.DataUserLogic 		 & Superato & 1 \\ 
					2013-05-15 & mytalk.client.presenter.user.logicUser.LogUserLogic 		 & Superato & 0 \\ 
					2013-05-15 & mytalk.client.presenter.user.logicUser.UpdateViewLogic 	 	& Superato & 1 \\ 
					2013-05-20 & mytalk.client.presenter.user.logicUser.RegisterLogic 		 & Superato & 0 \\									
					2013-05-22 & mytalk.client.presenter.user.logicUser.CommunicationLogic	 	& Superato & 0 \\
					2013-05-22 & mytalk.client.presenter.client.user.logicUser.common.CommonFunctions	 & Superato & 0 \\
					2013-05-22 & mytalk.client.presenter.user.serverComUser.WebSocketUser	 	& Superato & 0 \\	
					2013-05-25 & mytalkadmin.client.presenter.serverComUser.WebSocketAdmin	 	& Superato & 0 \\
					2013-05-03 & mytalk.server.presenter.XMLField & Superato & 0 \\
					2013-05-10 & mytalk.server.presenter.admin.logicAdmin.ManageWSA & Superato & 0 \\
					2013-05-02 &  mytalk.server.presenter.admin.logicAdmin.WSAdmin & Superato & 0 \\
					2013-05-15 & mytalk.server.presenter.user.logicUser.ManageWSU & Superato & 0 \\
					2013-05-01 & mytalk.server.presenter.user.logicUser.WSUser & Superato & 0 \\
					2013-05-08 & mytalk.server.model.dao.DataAccessObject	 & Superato & 0 \\
					2013-05-03 & mytalk.server.model.dao.ObjectTransfer	 	& Superato & 0 \\
					\bottomrule
				\end{tabular}
			\end{center}	
			\caption{Riassunto dell'esito dei test di unità} 
		\end{table}
	}
	
	\subsection{Tabella riassuntiva dei test di integrazione}{
		\begin{table}[h!]
			\scriptsize
			\begin{center}
				\begin{tabular}{c l l c}				
					\toprule
					Data 	& Ambito & Codice Verifica & Esito \\ 
					\midrule
					2013-06-03 & Utente & TI - Login	& Superato\\ 
					2013-06-03 & Utente & TI - gestione dati & Superato\\ 
					2013-06-04 & Utente & TI - Communicaton	 & Superato\\ 
					2013-06-05 & Amministratore & TI - Login	 	& Superato\\ 
					2013-06-06 & amministratore & TI - Statistic	 & Superato  \\										
					\bottomrule
				\end{tabular}
			\end{center}	
			\caption{Riassunto dell'esito dei test di integrazione} 
		\end{table}
	}
	
	%inizio errori view
	\subsection{Errori riscontrati nella view}{
	Vengono riportati i problemi individuati nelle componenti utilizzate per realizzare l'interfaccia grafica.
	\begin{itemize}
		\item[•] L'uso dell'oggetto \texttt{RootPanel} viene limitato alla sola creazione della pagina, mentre in origine era utilizzato anche per l'aggiunta e la rimozione di componenti della GUI\g. Questo comportava il completo aggiornamento della pagina stessa, provocando una nuova creazione di tutti gli oggetti necessari all'applicazione.
		
		\item[•] I bottoni, inizialmente di tipo \texttt{SubmitButton} forzavano un aggiornamento della pagina, per questo sono stati sostituiti da bottoni di tipo \texttt{Button}, i quali richiamano semplicemente le funzionalità desiderate.
		
		\item[•] Corretto il bug che provocava la visualizzazione dell'utente stesso tra la lista dei contatti chiamabili.
	\end{itemize}		
	}
	%fine errori view
}